1. 基本数据类型

   答：number（数值），string（字符串），null（空），Boolean(布尔)，undefined（未定义），Symbol(符号)

   ​       复杂（引用）数据类型：数组，对象，函数，日期，正则

   

2. 检测数据类型的方法

   答：typeof（）=> 区分基本数据类型，instanceof（）=> 能够区分复杂数据类型，适合用于判断自定义的类实例对象

   ​       Object.prototype.toString.call ( ) =>  精准判断数据类型

   

3. Typeof null返回什么

   答：object

   

4. 不使用三方变量交换 a = 30 b =40的值

   答：通过[ES6](https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020)的解构赋值   [ a , b ] = [ b , a ] 

   a=a+b  b=a-b  a=a-b

5. 哪些类型转换成布尔值是false

   答：1、undefined（未定义，找不到值时出现）

   ​    2、null（代表空值）

   ​	3、false（布尔值的false，[字符串](https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020)"false"布尔值为true）

   ​	4、0（数字0，字符串"0"布尔值为true）

   ​	5、NaN（无法计算结果时出现，表示"非数值"；但是typeof NaN==="number"）

   ​	6、""（双引号）或''（单引号） （**空字符串，中间有空格时也是true**）

   

6. 保留2位小数点

   答：	1、Math.**floor**()，不四舍五入 ，向下取整  =>  num = Math.floor ( num *100 ) /100 

   ​	2、toFixed ( 2 ) 方法:保留两位，但改变成string  => num = num.toFixed ( 2 )

   

7. 判断一个数字是否是整数

   答：	1、**使用取余运算符判断**      =>   num % 1 === 0

   ​	2、**使用parseInt判断**          =>   if(val === parseInt(val))   

   ​	3、**使用 Math.round() 四舍五入、Math.ceil() 向上取整、Math.floor() 向下取整**

   

8. 取200-300[ m=200 , n=300 ]之间的随机数

   答：	Math.random()*(m-n)+n       *包含就+1就可以了

   

9. 截取字符串有哪些方法

   答：substr  语法：subStr（startindex，length）=> 从哪个索引开始截，截几个

   ​       substring  语法：subString（startindex，endindex）=>  从那个索引开始，到那个索引截止，end取不到

   

10. 预解析?

    答：	变量预解析：用var声明的变量可以提升声明

    ​	函数预解析：会提前声明整个函数体

    

11. 全局变量和局部变量的区别

    答：	全局变量具有全局作用域。全局变量只需在定义一次，就可以作用于所有的文件，关闭页面才会销毁。

    ​    	局部变量只有局部作用域。只会在局部环境中定义，只能作用于这个局部环境，使用完就会销毁。

    

12. **什么是作用域链**

    答：作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明       			的变量或者函数（先在自身查找，如果自身没有会向上访问，一直到访问到全局）

    

13. 什么是闭包 应用在哪里?

    答：	两个函数嵌套，里面的函数调用外部函数的变量

    ​	作用：保护变量不受外界影响

    ​	应用：在前端性能优化的时候，可以用闭包做数据缓存。减少内存消耗。

    

14. 节流 防抖

    答：	节流：节流是将多次执行变成每隔一段时间执行

    ​	防抖：防抖动是将多次执行变为最后一次执行

    ​		   可以减少HTTP请求，减轻后端压力

    

15. 箭头函数和普通函数的区别?为什么箭头函数不能用于构造函数?

    答：1.写法不一样，箭头函数如果只传一个参就不要用括号，后面的直接全部返回的话

    2.箭头函数里面的this指向上下文，普通函数谁调用指向谁

    3.箭头函数没有构造器，所以不能用于构造函数

    4.箭头函数没有argument

    

16. 函数的this指向 定时器 事件

    答：	定时器的this指向是window

    ​	事件的this指向是事件源

    ​	this指向：1、this总是指向函数的直接调用者

    ​			2、如果有new关键字，this指向new出来的对象

    ​			3、在事件中，this指向触发这个事件的对象

    

17. 改变this指向的方法 区别?

    答：	call，apply，bind 

    ​	call和apply 会立刻调用函数，改变this指向。bind不会立刻调用函数，返回一个新的已经改变了this指向的函数

    ​	传参不同(apply传数组，call，bind传单个参数)

    

18. 自调用函数?

    答：iife   ()()

    ​	可以防止变量污染全局

    ​	可以立即执行函数

    

19. 清空一个数组的方法有哪些?

    答：	1、直接重新赋值成为一个新数组     =>    arr=[ ]       这是新数组

    ​	2、将数组的length属性赋0              =>     arr.length = 0       这是原数组

    

20. 数组的方法

    答：	
        push     末尾追加一个元素

    ​	pop      末尾删除一个元素

    ​	unshift   最前面添加一个元素

    ​	shift    最前面删除一个元素

    ​	splice   按照索引截取数组中的元素        
       语法：arr.splice(开始索引,截取数目,替换的新元素)

    ​	slice   按照索引截取数组中的元素          
       语法：arr.slice(开始索引startindex，结束的索引endindex)    end取不到

    ​	reverse    反转数组

    ​	concat     把多个数组进行拼接

    ​	join   将数组转换成字符串

    ​	map   映射

    ​	filter   过滤

    ​	sort   冒泡排序

    ​	find   查找

    ​	forEach()     遍历数组

    ​	set   数组去重（ES6）

    

21. 数组去重的方法

    答：	
    1、set   数组去重（ES6）        
    语法：var arr =[1,12,2,3]；
    var  res = [... new  Set（arr）]

    ​	2、indexof

    ​	3、双层for循环

    

22. 统计某个元素出现的次数

    答：遍历这个字符串，创建一个空对象，判断当前元素 在对象中是否存在（obj【item】），如果存在，那么obj【index】=++ 如果不存在，那么就添加该属性到对象中

    

23. 数组排序

如果返回值大于 0，则位置互换。
如果返回值小于 0，则位置不变。

    答：   sort        语法：arr.sort（function（a，b）{return b-a}）                  返回a-b ：从小到大

    

24. 多维数组 多维数组扁平化

    答：   arr.flat（Infinity）

    

25. for循环和forEach的区别

    答：	for循环可以通过break来控制循环的流程（中断）

    ​	但是forEach不行，因为他是一个函数，没有返回值。

    

26. for in和for of的区别

    答：	for in：   let  arr  =  ['水果'，'肉'，'菜']

    ​		      for （ let  j  in  arr）{  console.log（j）  }            //    0  ，1  ，2

    ​	for in：可以用来遍历对象，也可以用来遍历数组 ( 遍历数组得到索引 ) ，会遍历到数组原型

    ​	for of：  for（  let  l  of  arr）{  console.log（l）  }            //    水果  ，肉  ，菜

    ​	for of：用于遍历数组，直接获得数组中元素的值，不会遍历到数组原型

    ​		    不能遍历对象

    

27. 遍历对象的方法 遍历所有的key value?

    答：for in

    

28. 创建一个对象的方式有哪些?

    答：new

    

29. new一个对象发生了什么?

    答：	1、在内存中创建一个空对象

    ​	2、执行函数中的代码

    ​	3、函数中的this指向会发生改变，指向第一步创建出来的对象

    ​	4、函数原型上的constructor会指向当前构造函数

    

30. 原型链,原型的作用什么?

    答：	prototype：每一个函数都自带一个prototype，他是一个对象空间

    ​	-proto-：每一个对象（实例）都有一个-proto-的属性

    

31. 继承的方式有哪些?

    答：类的继承、组合继承、构造函数继承、原型继承

    

32. Object.create的作用

    答：接收一个对象作为参数，返回一个新对象，传入的对象变成新对象的原型对象

    

33. 深拷贝和浅拷贝,如何实现深拷贝 lodash,JSON方法的缺点?

    答：	浅拷贝：拷贝对象的一层属性，深层属性不会拷贝

    ​		      1、展开运算符

    ​		      2、for in循环

    ​		      3、object.assign

    ​	深拷贝：1、递归            =>  缺点：消耗内存，消耗性能

    ​		       2、Josn方法（JSON对象转JS对象：JSON.parse(JSON对象)。   => 更消耗内存，

    ​					       JS对象转JSON对象：JSON.stringify(JS对象)）     => 会将对象的原型一起拷贝

    ​		       3、loadash库	  .cloneDeep的方法

    

34. 获取dom的方式有哪些?

    答：	getElementById

    ​	getElementByClassName

    ​	getElementByTagName

    ​	querySelector

    ​	querySelectorAll

    

35. 创建 修改 替换 增加 dom

    答：	创建：createElement() //创建一个具体的元素
    ​		   createTextNode() //创建一个文本节点

    ​	添加、移除、替换、插入节点：
    ​		   appendChild()
    ​		   removeChild()
    ​		   replaceChild()
    ​		   insertBefore()
    ​		   insertAfter()

    ​	查找节点：
    ​		   getElementsByTagName() //通过标签名称查找节点
    ​		   getElementsByName() //通过元素的name属性的值查找节点
    ​		   getElementById() //通过元素ID查找节点，具有唯一性
    ​

    

36. 获取浏览器的版本信息

    答：window中有一个对象叫做navigator

    ​	专门用来获取浏览器信息的

    

37. js操作页面跳转

    答：location的href属性，open方法，hostory对象的方法，location的assign方法

    

38. 历史记录有哪些方法?

    答：	history 对象包含用户在浏览器中访问过的页面的URL

    ​	**history.back ( ) 、history.forward ( ) 、history.go ( ) **

    

39. 本地存储 区别

    答：	cookie ，localStorage，sessionStorage

    ​	cookie：存储较小，4kb左右

    ​		      存储数量有限制，50条左右

     		      有时效性（生命周期）

    ​	localStorage：是永久存储，只有手动删除才会消失

    ​				同源状态下，可以多个页面共享数据

    ​				存储一般在5M左右

    ​	sessionStorage：会话存储在关闭页面时会消失

    ​				     同源状态下，页面不能共享数据

    

40. ES6新特性

    答：	1、增加了 let 和 const 命令，用来声明变量。

    ​	2、箭头函数

    ​	3、模块化语法

    ​	4、模板字符串

    ​	5、promise

    ​	6、展开运算符

    ​	7、类语法

    

41. let const var 

    答：	let：用于声明变量的关键字

    ​	      1、不能像var一样提升声明

    ​	      2、具备块级作用域（可向上，不可向下）

    ​	      3、不可重复声明变量

    ​	const：用于声明常量

    ​              1、声明的变量不能改变（除非是引用数据类型）

    ​	      2、具备块级作用域

    ​	      3、不可重复声明变量

    ​	      4、不能提升声明

    ​	var：用于声明变量的关键字

    ​	      1、不具备块级作用域

    ​	      2、可以重复声明

    ​	      3、可以重新赋值

    ​	      4、可以提升声明

    ​	      5、唯一的作用域在函数中

    

42. Set Map

    答：	1、Map中的元素时key-value（键值对）

    ​	      Set中的元素是值

    ​	2、Set是不允许出现重复的元素的

    ​	3、Map是不允许出现重复的key的

    

43. 处理异步的方法 

    答：ajax    promise

    

44. promise的方法 allSettled

    答：allSettled是promise的方法。并发请求的意思，成功或者失败都会返回结果

    

45. 事件循环

    答：JS的事件循环机制

    ​	1、当事件开始时,首先会进入`JS`主线程机制

    ​	2、先执行同步任务，异步执行就是等待,后面执行

    ​	3、当主线程空闲的时候，会读取执行异步任务

    ​	4、异步任务分为宏任务和微任务，先执行微任务，后执行宏任务

    常见的宏任务：`setTimeout setInterval I/O script`

    常见的微任务：`promise.then.catch`

    

46. 即时通讯用什么方式webcoket 和http请求的区别

    答：ws/http    webcoket只有一次握手，http有三次握手            webcoket可以解决即时通讯的

    

47. 三次握手 4次握手

    答：	三次握手：1、客户端给服务端发送一个SYN报文

    ​			  2、服务器收到SYN报文后，会回一个SYN + ACK报文

    ​			  3、客户端收到SYN + ACK报文后，会回一个ACK报文

    ​	四次挥手：1、客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT状态

    ​		          2、服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态

    ​			  3、服务端发送了一个FIN，用来关闭服务端到客户端的数据传输，服务端进入last_ack状态

    ​			  4、客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，

    ​			        确认序号为收到序号+1，服务器进入Close状态，完成挥手

    

48. gc机制和IIFE

    答：js自己的内存管理机制：当一些变量或者函数不在使用之后，自动释放其内存，闭包需要手动释放

    ​	IIFE:自调用函数

    

49. 面向对象的特性 继承 封装多态

    答：	1、封装：弱化代码逻辑，把相关方法给使用者即可（高内聚，低耦合）

    ​	2、继承：子类获取父类的属性方法，为了降低低内存的占用，较少代码的重复性

    ​	3、多态：同一操作作用于不同的对象上面，可以产生不同的解释和执行结果。

    

50. 触发回流（重排）的条件 触发重绘的条件?

    答：

    

51. get post请求的区别

    答：	1、安全方面，post优于get

    ​	2、性能方面，get比post快

    ​	3、传输内容大小，get有限制，post无限制

    ​	4、传递的参数，get放在url里面，post放在请求体中

    ​	5、传递的数据类型，post是任意类型一般是json，get只能是ascii编码

    ​	6、get会缓存数据，post不会除非手动设置



[TOC]

