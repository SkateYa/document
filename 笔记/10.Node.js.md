[TOC]



# 第一章、初识Node.js与内置模块

## 1.1、初识Node.js

### 1.1.1、Node.js简介

#### 1.1.1.1、什么是Node.js

Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

**==Node.js 是==**一个基于 Chrome V8 引擎的 **==JavaScript 运行环境==**。

> Node.js 的官网地址： https://nodejs.org/zh-cn/

#### 1.1.1.2、Node.js中的JavaScript运行环境

![](E:\笔记\图片\微信截图_20221223015645.png)

注意：

1. **==浏览器==**是 JavaScript 的**==前端运行环境==**。
2. **==Node.js==** 是 JavaScript 的**==后端运行环境==**。
3. Node.js 中**==无法调用==** DOM 和 BOM 等**==浏览器内置 API==**。

#### 1.1.1.3、Node.js可以做什么

Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位：

1. 基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用
2. 基于 Electron 框架（https://electronjs.org/），可以构建跨平台的桌面应用
3. 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目
4. 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…

总之：Node.js 是大前端时代的“大宝剑”，有了 Node.js 这个超级 buff 的加持，前端程序员的行业竞争力会越来越强！

#### 1.1.1.4、Node.js怎么学

浏览器中的 JavaScript 学习路径：

JavaScript 基础语法 + 浏览器内置 API（DOM + BOM） + 第三方库（jQuery、art-template 等）

Node.js 的学习路径：

JavaScript 基础语法 + Node.js 内置 API 模块（fs、path、http等）+ 第三方 API 模块（express、mysql 等）

---

### 1.1.2、Node.js 环境的安装

如果希望通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。

安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页（**https://nodejs.org/en/**），点击绿色的按钮，下载所需的版本后，双击直接安装即可。

<img src="E:\笔记\图片\微信截图_20221223021145.png" style="zoom: 67%;" />

#### 1.1.2.1、区分 LTS 版本和 Current 版本的不同

1. LTS 为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装 LTS 版本的 Node.js。
2. Current 为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装 Current 版本的 Node.js。但是，Current 版本中可能存在隐藏的 Bug 或安全性漏洞，因此不推荐在企业级项目中使用 Current 版本的 Node.js。

#### 1.1.2.2、查看已安装的Node.js 的版本号

打开**终端**，在终端输入命令 **==node –v==** 后，按下回车键，即可查看已安装的 Node.js 的版本号。

Windows 系统快速打开终端的方式：

使用快捷键（Windows徽标键 + R）打开运行面板，输入 cmd 后直接回车，即可打开终端。

#### 1.1.2.3、什么是终端

<img src="E:\笔记\图片\微信截图_20221223021555.png" style="zoom:67%;" />

终端（英文：Terminal）是专门为开发人员设计的，用于实现人机交互的一种方式。

作为一名合格的程序员，我们有必要识记一些**常用的终端命令**，来辅助我们更好的操作与使用计算机。

---

### 1.1.3、在Node.js 环境中执行 JavaScript 代码

1. 打开终端
2. 输入 node 要执行的js文件的路径

#### 1.1.3.1、终端中的快捷键

在 Windows 的 powershell 或 cmd 终端中，我们可以通过如下快捷键，来提高终端的操作效率：

- 使用 ↑ 键，可以快速定位到上一次执行的命令
- 使用 tab 键，能够快速补全路径
- 使用 esc 键，能够快速清空当前已输入的命令
- 输入 cls 命令，可以清空终端

---



## 1.2、fs 文件系统模块

### 1.2.1、什么是 fs 文件系统模块

==fs 模块==是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。

例如：

- **==fs.readFile()==** 方法，用来**==读取==**指定文件中的内容
- **==fs.writeFile()==** 方法，用来向指定的文件中**==写入==**内容

如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它：

~~~javascript
const fs = require("fs");
~~~

### 1.2.2、读取指定文件中的内容

#### 1.2.2.1、fs.readFile() 的语法格式

使用 fs.readFile() 方法，可以读取指定文件中的内容，语法格式如下：

~~~javascript
fs.readFile(path[,options],callback)
~~~

参数解读：

- 参数1：==必选==参数，字符串，表示文件的路径。
- 参数2：可选参数，表示以什么==编码格式==来读取文件。
- 参数3：==必选==参数，文件读取完成后，通过回调函数拿到读取的结果。

#### 1.2.2.2、fs.readFile() 的示例代码

以 utf8 的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值：

~~~javascript
fs.readFile('./files/1.txt', 'utf8', function(err, dataStr) {
  // 2.1 打印失败的结果
  // 如果读取成功，则 err 的值为 null
  // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined
  console.log(err)
  console.log('-------')
  // 2.2 打印成功的结果
  console.log(dataStr)
})
~~~

#### 1.2.2.3、判断文件是否读取成功

可以判断 err 对象是否为 null，从而知晓文件读取的结果：

~~~javascript
const fs = require('fs');

fs.readFile('./files/1.txt','utf-8',function(err,result) {
    if(err) {
        return console.log('读取文件失败！' + err.message);
    }
    	return console.log('读取文件成功' + result);
})
~~~

---

### 1.2.3、向指定的文件中写入内容

#### 1.2.3.1、fs.writeFile() 的语法格式

使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下：

~~~javascript
fs.writeFile(file,data[,options],callback)
~~~

参数解读：

- 参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。
- 参数2：必选参数，表示要写入的内容。
- 参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。
- 参数4：必选参数，文件写入完成后的回调函数。

#### 1.2.3.2、fs.writeFile() 的示例代码

向指定的文件路径中，写入文件内容：

~~~javascript
// 1. 导入 fs 模块
const fs = require('fs');
fs.writeFile(./'./成绩.txt', 'utf8', function(err) {
        console.log(err);
}
~~~

#### 1.2.3.5、判断文件是否称成功写入

可以判断 err 对象是否为 null，从而知晓文件写入的结果：

~~~javascript
// 1. 导入 fs 模块
const fs = require('fs');
// 2. 调用 fs.readFile() 读取文件的内容
fs.readFile('./成绩.txt', 'utf8', function(err, result) {
  // 3. 判断是否读取成功
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
   console.log('读取文件成功！' + result)
})
~~~

---

### 1.2.4、向指定的文件中写入内容

#### 1.2.4.1、fs.writeFile() 的语法格式

使用 fs.writeFile() 方法，可以向指定的文件中写入内容，语法格式如下：

~~~javascript
fs.writeFile(file,data[,options],callback)
~~~

参数解读：

- 参数1：**==必选==**参数，需要指定一个**==文件路径的字符串==**，表示文件的存放路径。
- 参数2：**==必选==**参数，表示要写入的内容。
- 参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。
- 参数4：**==必选==**参数，文件写入完成后的回调函数。

#### 1.2.4.2、fs.writeFile() 的示例代码

向指定的文件路径中，写入文件内容：

~~~javascript
const fs = require('fs');
fs.writeFile('./files/.txt','Hello Node.js!', function(err) {
    console.log(err);
})
~~~

#### 1.2.4.3、判断文件是否写入成功

可以判断 err 对象是否为 null，从而知晓文件写入的结果：

~~~javascript
const fs = require('fs');
fs.writeFile('./files/成绩-ok.txt','Hello Node.js!', function(err) {
    if (err) {
      return console.log('写入文件失败！' + err.message);
    }
    console.log('成绩写入成功！');
})
~~~

---

### 1.2.5、fs 模块 - 路径动态拼接的问题

在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。

原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。

解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。

解决办法：

**==__dirname==** 表示当前文件所处的目录

~~~javascript
fs.readFile(__dirname + '/files/1.txt', 'utf8', function(err, dataStr) {
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  console.log('读取文件成功！' + dataStr)
})
~~~

---



## 1.3、path 路径模块

### 1.3.1、什么是 path 路径模块

path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。

例如：

- path.join() 方法，用来==将多个路径片段拼接成一个完整的路径字符串==
- path.basename() 方法，用来从路径字符串中，将文件名解析出来

如果要在 JavaScript 代码中，使用 path 模块来处理路径，则需要使用如下的方式先导入它：

~~~javascript
const path = require('paht');
~~~

### 1.3.2、路径拼接

#### 1.3.2.1、path.join() 的语法格式

使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：

~~~javascript
path.join([...pahts]);
~~~

参数解读：

- ...paths <string> 路径片段的序列
- 返回值：<string>

#### 1.3.2.2、path.join() 的代码示例

使用path.join() 方法，可以把多个路径片段拼接为完整的路径字符串：

~~~javascript
const pathStr = path.join('/a','/b/c','../d','e');
console.log(pathStr);  // 输出 \a\b\d\e

const pathStr2 = path.join(__dirname,'files/1.txt')
console.log(pathStr2); // 输出 当前文件所处目录\files\1.txt
~~~

> 注意：今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接。

---

### 1.3.3、获取路径中的文件名

#### 1.3.3.1、path.basename() 的语法格式

使用path.basename() 方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：

~~~javascript
path.basename(path[,ext])
~~~

参数解读：

- path <string> 必选参数，表示一个路径的字符串
- ext <string> 可选参数，表示文件扩展名
- 返回: <string> 表示路径中的最后一部分

#### 1.3.3.2、path.basename() 的代码示例

使用 path.basename() 方法，可以从一个文件路径中，获取到文件的名称部分：

~~~javascript
const fpath = ‘/a/b/c/index.html’; // 文件的存放路径

var fuuName = path.basename(fpath);
console.log(fullName); // 输出index.html

var nameWithoutExt = path.basename(fpath,'.html');
console.log(nameWithoutExt)  // 输出 index
~~~

### 1.3.4、获取路径中的文件扩展名

#### 1.3.4.1、path.extname() 的语法格式

使用 path.extname() 方法，可以获取路径中的扩展名部分，语法格式如下：

~~~javascript
path.extname(path)
~~~

参数解读：

- path <string>必选参数，表示一个路径的字符串
- 返回：<string> 返回得到的扩展名字符串

#### 1.3.4.2、path.extname() 的代码示例

使用 path.extname() 方法，可以获取路径中的扩展名部分：

~~~javascript
const path =  require("path");

const fpath = '/a/b/c/index.html';   // 路径字符串
const fext = path.extname(fpath);
console.log(fext); // 输出 .html
~~~

---



## 1.4、http模块

### 1.4.1、什么是http模块

在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。

==http== 模块是 Node.js 官方提供的、用来==创建 web 服务器==的模块。通过 http 模块提供的 ==http.createServer()== 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。

如果希望使用http模块创建Web服务器，则需要先导入它：

~~~javascript
const http = require('http');
~~~

### 1.4.2、进一步理解http模块的作用

服务器和普通电脑的**==区别==**在于，服务器上安装了 ==web 服务器软件==，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。

### 1.4.3、服务器相关的概念

####  1.4.3.1、IP地址

==IP地址==就是互联网上==每台计算机的唯一地址==，因此 IP 地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。

IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1）

注意：

1. 互联网中每台 Web 服务器，都有自己的 IP 地址，例如：大家可以在 Windows 的终端中运行 ping www.baidu.com 命令，即可查看到百度服务器的 IP 地址。、
2. 在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入 127.0.0.1 这个 IP 地址，就能把自己的电脑当做一台服务器进行访问了。

#### 1.4.3.2、域名和域名服务器

尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的**==域名（Domain Name）地址==**。

==IP地址==和==域名==是一一对应的关系，这份对应关系存放在一种叫做**==域名服务器==**(DNS，Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，**==域名服务器就是提供IP地址和域名之间的转换服务的服务器==**

>  注意：
>
> 1. 单纯使用 IP 地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。
> 2. 在开发测试期间， 127.0.0.1 对应的域名是 localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

#### 1.4.3.3、端口号

计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。

同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给==对应的 web 服务==进行处理。

![](E:\笔记\图片\微信截图_20230112122010.png)

> 注意：
>
> 1. 每个端口号不能同时被多个 web 服务占用。
> 2. 在实际应用中，URL中的**==80端口可以被省略==**

---

### 1.4.4、创建最基本的web服务器

基本步骤：

1. 导入http模块
2. 创建web服务器实例
3. 为服务器实例绑定**==request==**事件，监听客户端的请求
4. 启动服务器

---

#### 1.4.4.1、步骤1 - 导入 http 模块

如果希望在自己的电脑上创建一个web服务器，从而对外提供web服务，则需要导入 http 模块：

~~~javascript
const http = require('http');
~~~

#### 1.4.4.2、步骤2 - 创建 web 服务器实例

调用 http.createServer() 方法，即可快速创建一个 web 服务器实例：

~~~javascript
const server = http.creatServer()
~~~

#### 1.4.4.3、步骤3 - 为服务器实例绑定 request 事件

~~~javascript
// 使用服务器实例的 .on() 方法, 为服务器绑定一个 request 事件
server.on('request',(req,res) =>{
// 只要有客户端来请求我们的服务器，就会触发 request 事件, 从而调用这个事件处理函数
    console.log('Someone visit our web sever')
}) 
~~~

#### 1.4.4.4、步骤4 - 启动服务器

调用服务器实例的 .listen() 方法 ，即可启动当前的web 服务器实例：

~~~javascript
// 调用 server .listen(端口号,cb回调) 方法，即可启动 web 服务器
server .listen(80,() => {
    console.log('http server running at http://127.0.0.1')
})
~~~

#### 1.4.4.5、req请求对象

只要服务器接收到了客户端的请求，就会调用通过 **==server.on()==** 为服务器绑定的 **==request 事件处理函数==**。

如果想在事件处理函数中，访问与客户端相关的**==数据==**或**==属性==**，可以使用如下的方式：

```node.js
server.on('request',(req) => {
	// req 是请求对象，它包含了与客户端相关的数据和属性，例如:
	// req.url 是客户端请求的URL 地址
	// req.method 是客户端的 method 请求类型
	const str = 'Your request url is ${req.url},and request is ${req.method}';
	console.log(str);
});
```

#### 1.4.4.6、res响应请求

在服务器的 request 事件处理函数中，如果想访问与服务器相关的**数据**或**属性**，可以使用如下的方式：

```
server.on('request',(req,res) => {
	// res 是响应对象，它包含了与服务器相关的数据和属性, 例如:
	// 要发送到客户端的字符串
	const str = 'Your request url is ${req.url},and request method is ${req.method}'
	// res.end() 方法的作用
	// 向客户端发送指定的内容，并结束这次请求的处理过程
	res.end(str)
})
```

#### 1.4.4.7、解决中文乱码问题

当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动**==设置内容的编码格式==**：

```node.js
server.on('request',(req,res) => {
	// 发送的内容包含中文
	const str = '您的请求URL地址是${req.url},请求的method 类型是 ${req.method}'
	// 为了防止中文显示乱码的问题，需要设置响应头 Content-Type 的值为 text/html; 				charset=utf-8
	res.setHeader('Content-Type,text/html; charset=utf=8')
	// 把包含中文的内容,响应给客户端
	res.end(str)
})
```

---





# 第二章、模块化

## 2.1、模块化的基本概念

### 2.1.1、什么是模块化

**模块化**是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。

---

编程领域中的模块化，就是**遵守固定的规则**，==把一个大文件拆成独立并互相依赖的多个小模块==。

把代码进行模块化拆分的好处：

1. 提高了代码的复用性
2. 提高了代码的可维护性
3. 可以实现按需加载

---

## 2.2、Node.js中模块化的分类

### 2.2.1、Node.js 中模块的分类

Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：

- 内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等）
- 自定义模块（用户创建的每个 .js 文件，都是自定义模块）
- 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）

---

### 2.2.2、加载模块

使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：

```javascript
// 1.加载内置的 fs 模块
const fs = require('fs');

// 2. 加载用户的自定义模块
const custom = require('./custom.js');

// 3. 加载第三方模块
const moment = require('moment');
```

> 注意：使用 require() 方法加载其它模块时，会执行被加载模块中的代码。

---

### 2.2.3、Node.js中的模块作用域

1. 什么是模块作用域

   和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做**==模块作用域==**。

   ![](E:\笔记\图片\微信截图_20230225100227.png)

2. 模块作用域的好处

   防止了全局变量污染的问题

---

### 2.2.4、向外共享模块作用域中的成员

1. module对象

   在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下：

   ![](E:\笔记\图片\微信截图_20230225100604.png)

2. module.exports 对象

   在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。

   外界用 ==**require()**== 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。

3. 共享成员时的注意点

   使用 require() 方法导入模块时，导入的结果，==**永远以 module.exports 指向的对象为准**==。

   ![](E:\笔记\图片\微信截图_20230225101020.png)

4. **exports 对象**

   由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。**==默认情况下，exports 和 module.exports 指向同一个对象==**。最终共享的结果，还是以 module.exports 指向的对象为准。

   ![](E:\笔记\图片\微信截图_20230225101310.png)

5. exports 和 module.exports 的使用误区

   时刻谨记，require() 模块时，得到的永远是 **==module.exports==** 指向的对象：

   ![](E:\笔记\图片\微信截图_20230225101522.png)

   > **注意：**为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports

### 2.2.5、Node.js 中的模块化规范

Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。

CommonJS 规定：

1. 每个模块内部，**==module 变量==**代表当前模块。
2. module 变量是一个对象，它的 exports 属性**==（即 module.exports）是对外的接口。==**
3. 加载某个模块，其实是加载该模块的 module.exports 属性。**==require() 方法用于加载模块==**。

---



## 2.3、npm与包

### 2.3.1、包

1. 什么是包

   Node.js 中的**==第三方模块==**又叫做**==包==**。

   就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。

2. 包的来源

   不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。

   **注意**：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。

3. 为什么需要包

   由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。

   **==包是基于内置模块封装出来的==**，提供了更高级、更方便的 API，极大的提高了开发效率。

   包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系。

4. 从哪里下载包

   国外有一家 IT 公司，叫做 **npm, Inc.** 这家公司旗下有一个非常著名的网站： https://www.npmjs.com/ ，它是**全球最大的包共享平台**，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！

   **npm, Inc.** **公司**提供了一个地址为 https://registry.npmjs.org/ 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。

   > 从 https://www.npmjs.com/ 网站上搜索自己所需要的包
   >
   > 从 https://registry.npmjs.org/ 服务器上下载自己需要的包

5. 如何下载包

   **npm, Inc.** **公司**提供了一个包管理工具，我们可以使用这个包管理工具，从 https://registry.npmjs.org/ 服务器把需要的包下载到本地使用。

   这个包管理工具的名字叫做 **==Node Package Manager（简称 npm 包管理工具）==**，这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。

   大家可以在终端中执行 **npm -v** 命令，来查看自己电脑上所安装的 npm 包管理工具的版本号：

   ![](E:\笔记\图片\微信截图_20230225103013.png)

---

### 2.3.2、npm初体验

#### 2.3.2.1、在项目中安装包的命令

如果想在项目中安装指定名称的包，需要运行如下的命令：

```node.js
npm install 包的完整名称
```

上述的装包命令，可以简写成如下格式：

```
npm i 完整的包名称
```

#### 2.3.2.2、初次装包后多了哪些文件

初次装包完成后，在项目文件夹下多一个叫做 **node_modules** 的文件夹和 **package-lock.json** 的配置文件。

其中：

node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。

package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。

> 注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。

#### 2.3.2.3、安装指定版本的包

默认情况下，使用 npm install 命令安装包的时候，**==会自动安装最新版本的包==**。如果需要安装指定版本的包，可以在包名之后，通过 **==@ 符号==**指定具体的版本，例如：

```
npm i moment@2.22.2
```

#### 2.3.2.4、包的语义化版本规范

包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 **2.24.0**

其中每一位数字所代表的的含义如下：

第1位数字：大版本

第2位数字：功能版本

第3位数字：Bug修复版本

版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。

---

### 2.3.3、包管理配置文件

npm 规定，在项目根目录中，**必须**提供一个叫做 **==package.json==** 的包管理配置文件。用来记录与项目有关的一些配置信息。例如：

- 项目的名称、版本号、描述等
- 项目中都用到了哪些包
- 哪些包只在开发期间会用到
- 那些包在开发和部署时都需要用到

#### 2.3.3.1、dependencies 节点

package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。

![](E:\笔记\图片\微信截图_20230225160313.png)

#### 2.3.3.2、一次性安装所有的包

可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包：

```node.js
1. // 执行 npm install 命令时，npm包管理工具会先读取 package.json 中的 dependencies 节点，
2. // 读取到记录的所有依赖包名称和版本号之后，npm 包管理工具会把这些包一次性下载到项目中
npm install
```

#### 2.3.3.3、卸载包

可以运行 npm uninstall 命令，来卸载指定的包：

```node.js
1. // 使用 npm uninstall 具体的包名  来卸载包
2. npm uninstall moment
```

> 注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。

#### 2.3.3.4、devDependencies 节点

如果某些包**只在项目开发阶段**会用到，在**项目上线之后不会用到**，则建议把这些包记录到 devDependencies 节点中。

与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。

您可以使用如下的命令，将包记录到 devDependencies 节点中：

```
1.// 安装指定的包， 并记录了到 devDependencies 节点中
2. npm i 包名 -D
// 注意：上述命令是简写形式，等价于下面完整的写法:
npm install 包名 --save-dev
```

---

### 2.3.4、解决下包速度慢的问题

#### 2.3.4.1、切换npm的下包镜像源 ----> nrm

下包的镜像源，指的就是下包的服务器地址。

为了更方便的切换下包的镜像源，我们可以安装 **nrm** 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。

```
# 通过 npm 包管理工具, 将nrm 安装为全局可用的工具
npm i nrm -g
# 查看所有可用的镜像源
nrm ls
# 将下包的镜像源切换为 taobao 镜像
nrm use taobao
```

---

### 2.3.5、包的分类

使用 npm 包管理工具下载的包，共分为两大类，分别是：

- 项目包
- 全局包

#### 2.3.5.1、项目包

那些被安装到项目的 node_modules 目录中的包，都是项目包。

项目包又分为两类，分别是：

- 开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到）
- 核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）

```node.js
npm i 包名 -D  # 开发依赖包 (会被记录到DevDependencies 节点下)
npm i 包名 # 核心依赖包 (会被记录到 Dependencies 节点下)
```

#### 2.3.5.2、全局包

在执行 npm install 命令时，如果提供了 **==-g==** 参数，则会把包安装为**==全局包==**。

全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。

```
npm i 包名 -g # 全局安装指定的包
nom uninstall 包名 -g # 卸载全局安装的包
```

注意：

> **==只有工具性质的包==**，才有全局安装的必要性。因为它们提供了好用的终端命令。
>
> 判断某个包是否需要全局安装后才能使用，可以**==参考官方提供的使用说明==**即可。

#### 2.3.5.3、规范的包结构

一个规范的包，它的组成结构，必须符合以下 3 点要求：

1. 包必须以==单独的目录==而存在
2. 包的顶级目录下要必须包含 ==package.json== 这个包管理配置文件
3. package.json 中必须包含 ==name==，==version==，==main== 这三个属性，分别代表包的名字、版本号、包的入口。

---

### 2.3.6、模块的加载机制

#### 2.3.6.1、优先从缓存中加载

**模块在第一次加载后会被缓存**。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。

注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。

#### 2.3.6.2、内置模块的加载机制

内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。

例如，require('fs') 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。

#### 2.3.6.3、自定义模块的加载机制

使用 require() 加载自定义模块时，**==必须指定以 ./ 或 ../ 开头的路径标识符==**。在加载自定义模块时，如果没有指定 ./ 或 ../ 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。

同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：

1. 按照确切的文件名进行加载
2. 补全 .js 扩展名进行加载
3. 补全 .json 扩展名进行加载
4. 补全 .node 扩展名进行加载
5. 加载失败，终端报错

#### 2.3.6.4、第三方模块的加载机制

如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。

**==如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。==**

例如，假设在 'C:\Users\itheima\project\foo.js' 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找：

1.  C:\Users\itheima\project\node_modules\tools
2.  C:\Users\itheima\node_modules\tools
3.  C:\Users\node_modules\tools
4.  C:\node_modules\tools

---



# 第三章、Express

## 3.1、初识Express

### 3.1.1、什么是Express

官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 **==Web 开发框架。==**

通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，**==是专门用来创建 Web 服务器的==**。

> **Express** **的本质**：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。

Express 的中文官网：[ http://www.expressjs.com.cn/](http://www.expressjs.com.cn/)

---

### 3.1.2、进一步理解Express

思考：不使用 Express 能否创建 Web 服务器？

答案：能，使用 Node.js 提供的原生 http 模块即可。

---

思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？

答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率。

---

思考：http 内置模块与 Express 是什么关系？

答案：类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的。

### 3.1.3、Express能做什么

对于前端程序员来说，最常见的两种服务器，分别是：

- Web 网站服务器：专门对外提供 Web 网页资源的服务器。
- API 接口服务器：专门对外提供 API 接口的服务器。

使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。

---

## 3.2、Express 的基本使用

### 3.2.1、安装

在项目所处的目录中，运行如下的终端命令，即可将 express 安装到项目中使用：

```node.js
npm i express@4.17.1
```

### 3.2.2、创建最基本的Web 服务器

```node.js
// 1. 导入 express
const express  = require('express')
// 2. 创建web 服务器
const app = express()

 // 3. 调用app.listen(端口号,启动成功后的回调函数),启动服务器
 app.listen(80,() => {
  console.log('express server running at http://127.0.0.1')
 })
```

### 3.2.3、监听 GET 请求

通过 app.get() 方法，可以监听客户端的 GET 请求，具体的语法格式如下：

```node.js
// 参数1: 客户端请求的URL地址
// 参数2: 请求对应的处理函数
//   req:请求对象(包含了与请求相关属性与方法)
	 res:响应请求(包含了与响应相关属性与方法)
app.get('请求url',function(req,res) {/*处理函数*/})
```

### 3.2.4、监听 POST 请求

通过 app.post() 方法，可以监听客户端的 POST 请求，具体的语法格式如下：

```node.js
// 参数1: 客户端请求的URL地址
// 参数2: 请求对应的处理函数
//   req:请求对象(包含了与请求相关属性与方法)
	 res:响应请求(包含了与响应相关属性与方法)
app.post('请求url',function(req,res) {/*处理函数*/})
```

### 3.2.5、把内容响应给客户端

通过 **==res.send() 方法==**，可以把处理好的内容，发送给客户端：

```node.js
app.get('/user',(req,res) => {
	//向客户端发送 JSON 对象
	res.send({name:'zs',age:20,gender:'男'})
})

app.post('/user',(req,res) => {
	//向客户端发送文本内容
	res.send('请求成功')
})
```

### 3.2.6、获取URL 中携带的查询参数

通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：

```node.js
 app.get('/ ，(req,res) => {
// req.query 默认是一个空对象
// 客户端使用 ?name=zs&age=20 这种查询字符串形式，发送到服务器的参数// 可以通过 req.query 对象访问到，例如:
// req.query.name     req.query.age
console.log(req.query)
})
```

### 3.2.7、获取URL 中的动态参数

通过 req.params 对象，可以访问到 URL 中，通过 **:** 匹配到的动态参数：

```node.js
// URL 地址中，可以通过 :参数名 的形式，匹配动态参数值
app.get('/user/:id'，(req，res) => {
// req.params 默认是一个空对象
//里面存放着通过:动态配到的参数值
console.log(req.params)
})
```

---

## 3.3、托管静态资源

### 3.3.1、express.static()

express 提供了一个非常好用的函数，叫做 **==express.static()==**，通过它，我们可以==非常方便地创建==一个==静态资源服务器==，例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：

```
app.use('express.static('public')')
```

现在，你就可以访问 public 目录中的所有文件了：

> **注意：**Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在 URL 中。

### 3.3.2、托管多个静态资源项目

如果要托管多个静态资源目录，请多次调用 express.static() 函数：

```node.js
app.use(express.static('public'))
app.use(express.static('files'))
```

访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。

### 3.3.3、挂载路径前缀

如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：

```node.js
app.use('./public',express.static('public'))
```

现在，就可以通过带有 /public 前缀地址来访问 public 目录中的文件了：

![](E:\笔记\图片\微信截图_20230227091223.png)



## 3.4、nodemon

在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。

现在，我们可以使用 nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够**==监听项目文件的变动==**，当代码被修改后，nodemon 会**==自动帮我们重启项目==**，极大方便了开发和调试。

### 3.4.1、安装nodemon

在终端中，运行如下命令，即可将 nodemon 安装为全局可用的工具：

```node.js
npm install -g nodemon
```

### 3.4.2、使用nodemon

当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 **==node app.js==** 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目

现在，我们可以将 node 命令替换为 nodemon 命令，使用 **==nodemon app.js==** 来启动项目。这样做的好处是：代码被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。

```ndoe.js
node app.js
# 将上面的终端命令,替换为下面的终端命令,即可实现自动重启项目的效果
nodemon app.js
```

---



## 3.5、Express 路由

### 3.5.1、路由的概念

广义上来讲，路由就是映射关系。

现实生活中的路由

![](E:\笔记\图片\微信截图_20230227094756.png)

在这里，路由是**==按键==**与**==服务==**之间的**==映射关系==**

---

#### 3.5.1.1、Express 中的路由

在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。

Express 中的路由分 3 部分组成，分别是**==请求的类型==**、**==请求的 URL 地址==**、**==处理函数==**，格式如下：

```node.js
app.MEHTOD(path.funciton)
```

#### 3.5.1.2、Express中的路由的例子

```node.js
//匹配 GET请求，且请求URL 为 /
app.get('/'，function (req,res) {
	res.send('Hello World!')
})

// 匹配POST请求，且请求 URL 为 /
app.post('/ ，function (req, res) {
	res .send( ' Got a POST request')
})
```

#### 3.5.1.3、路由器的匹配过程

每当一个请求到达服务器之后，**==需要先经过路由的匹配==**，只有匹配成功之后，才会调用对应的处理函数。

在匹配时，会按照路由的顺序进行匹配，如果**==请求类型==**和**==请求的 URL==** 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。

![](E:\笔记\图片\微信截图_20230301125253.png)

> 路由匹配的注意点：
>
> 1. 按照定义的先后顺序进行匹配
> 2. 请求类型和请求的URL同时匹配成功，才会调用对应的处理函数

---

### 3.5.2、路由的使用

#### 3.5.2.1、最简单的用法

在 Express 中使用路由最简单的方式，就是把路由挂载到 app 上，示例代码如下：

```node.js
const express = require( ' express')
// 创建 Web 服务器，命名为 app
const app = express( )

// 挂载路由
app.get('/', (req, res) => {res .send( 'Hello world.' )})
app.post('/'(req, res) => {res.send('post Request.') })

// 启动 web 服务器
app.listen(80, () => { console.log('server running at http://127.0.0.1') ))
```

#### 3.5.2.2、模块化路由

为了方便对路由进行模块化的管理，Express **不建议**将路由直接挂载到 app 上，而是**==推荐将路由抽离为单独的模块。==**

将路由抽离为单独模块的步骤如下：

1. 创建路由模块对应的 .js 文件
2. 调用 **==express.Router()==** 函数创建路由对象
3. 向路由对象上挂载具体的路由
4. 使用 ==**module.exports**== 向外共享路由对象
5. 使用 ==**app.use()**== 函数注册路由模块

#### 3.5.2.3、创建路由模块

```node.js
var express = require('express')        // 1.导入 express
var router = express .Router()     		// 2.创建路由对象
router.get('/user/list，function (req，res){    // 3.挂载获取用户列表的路由
	res .send( ' Get user list .' )
)}
router.post('/user/add'，function (req，res) {	// 4.挂载添加用户的路由
	res . send( ' Add new user .' )
})

module.exports = router						// 5.向外导出路由对象
```

#### 3.5.2.4、注册路由模块

```node.js
// 1.导入路由模块
const userRouter = require('./router/user .js')

// 2.使用 app.use() 注册路由模块
app.use(userRouter)
```

#### 3.5.2.5、为路由模块添加前缀

类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：

```node.js
// 1.导入路由模块
const userRouter = require('./router/user .js')

// 2.使用 app.use() 注册路由模块
app.use('/api'userRouter)
```

