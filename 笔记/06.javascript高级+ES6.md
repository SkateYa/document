[TOC]



# 第一章、Javascript面向对象

## 1.1、面向对象编程介绍

两大编程思想

- 面向过程
- 面向对象

### 1.1.1、面向过程编程 POP(Process-oriented programming)

**面向过程**就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。

举个例子：将大象装进冰箱，面向过程做法。

<img src="E:\笔记\图片\微信截图_20221127210944.png" style="zoom:80%;" />

==面向过程，就是按照我们分析好了的步骤，按照步骤解决问题==。

### 1.1.2、面向对象编程OOP（Object Oriented Programming）

**面向对象**是把事务分解成为一个个对象，然后由对象之间分工与合作。

举个例子：将大象装进冰箱，面向对象做法。

先找出对象，并写出这些对象的功能：

1. 大象对象
   - 进去
2. 冰箱对象
   - 打开
   - 关闭
3. 使用大象和冰箱的功能

==面向对象是以对象功能来划分问题，而不是步骤==。

在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。

面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。

面向对象的特性：

- 封装性
- 继承性
- 多态性

### 1.1.3面向过程和面向对象的对比

面向过程

- 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。
- 缺点：没有面向对象易维护、易复用、易扩展

面向对象

- 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
- 缺点：性能比面向过程低

用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。



## 1.2、ES6中的类和对象

面向对象的思维特点: 

1. 抽取（抽象）对象共用的属性和行为组织(封装)成一个类(模板)
2. 对类进行实例化, 获取类的对象

面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点,不断的创建对象,使用对象,指挥对象做事情.

### 1.2.1、对象

现实生活中：万物皆对象，对象是==一个具体的事物==，看得见摸得着的实物。例如，一本书、一辆汽车、一个人可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。

在JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。

对象是由==属性==和==方法==组成的：

- 属性：事物的==特征==，在对象中用==属性==来表示（常用名词）
- 方法：事物的==行为==，在对象中用==方法==来表现（常用动词）

### 1.2.2、类

在 ES6 中新增加了类的概念，可以使用==class==关键字声明一个类，之后以这个类来实例化对象。

==类==抽象了对象的公共部分，它泛指某一大类（class）

==对象==特指某一个，通过类实例化一个具体的对象  

![](E:\笔记\图片\微信截图_20221128021910.png)

#### 1.2.2.1、创建类

语法：

~~~javascript
// 1. 创建类 calss  创建一个 明星类
        class Star {
            constructor(uname,age) {
                this.uname = uname;
                this.age = age;
            }
        }
~~~

创建实例：

~~~javascript
// 2. 利用类创建对象 new
        var ldh = new Star('刘德华');
        var zxy = new Star('张学友');
~~~

> 注意：类必须使用new实例化对象

#### 1.2.2.2、类constructor构造函数

==constructor()== 方法是类的构造函数(默认方法)，==用于传递参数,返回实例对象==，通过 new 命令生成对象实例时，自动调用该方法。如果没有显示定义, 类内部会自动给我们创建一个==constructor()==

语法：

~~~javascript
// 1. 创建类 calss  创建一个 明星类
        class Star {
            constructor(uname,age) {
                this.uname = uname;
                this.age = age;
            }          
        }
		//(1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写
        //(2) 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象
        //(3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数
        //(4) 生成实例 new 不能省略
        //(5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function
~~~

创建实例：

~~~javascript
var ldh = new Person('刘德华', 18); 
console.log(ldh.name);
~~~

#### 1.2.2.3、类添加方法

语法：

~~~javascript
// 1. 创建类 calss  创建一个 明星类
        class Star {
            constructor(uname,age) {
                this.uname = uname;
                this.age = age;
            }
            sing(song) {
                console.log(this.uname + song);
            }
        }
~~~

创建实例：

~~~javascript
// 2. 利用类创建对象 new
        var ldh = new Star('刘德华',18);
        var zxy = new Star('张学友',20);
        console.log(ldh);
        console.log(zxy);
        // (1) 我们类里面所有的函数不需要写function
        // (2) 多个函数方法之间不需要添加逗号分隔
        ldh.sing('冰雨');
        zxy.sing('李香兰');
~~~

> 注意：方法之间不能加逗号分隔，同时方法不需要添加 function 关键字。

### 1.2.3、类的继承

现实中的继承：子承父业，比如我们都继承了父亲的姓。

程序中的继承：子类可以继承父类的一些属性和方法。

语法：

~~~javascript
class Father{   // 父类
} 
class  Son extends Father {  // 子类继承父类
}       
~~~

实例：

~~~javascript
class Father {
      constructor(surname) {
        this.surname= surname;
      }
      say() {
        console.log('你的姓是' + this.surname);

       }
}
class Son extends Father{  // 这样子类就继承了父类的属性和方法

}
var damao= new Son('刘');
damao.say();   
~~~

### 1.2.4、super关键字

==super== 关键字用于访问和调用对象父类上的函数。==可以调用父类的构造函数==，也可以调用父类的普通函数

语法：

~~~javascript
<script>
        // super 关键字调用父类普通函数
        class Father {
            say() {
                return '我是爸爸';
            }
        }
        class Son extends Father {
            say () {
                console.log(super.say() + '的儿子');
                // super.say() 就是调用父类中的普通函数 say()
            }
        }
        var son = new Son;
        son.say();
        // 继承中的属性或者方法查找原则: 就近原则
        // 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的
        // 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)
    </script>
~~~

> 注意事项：

1. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象
2. **==类里面的共有属性和方法一定要加this使用==**
3. 类里面的this指向问题
4. **==constructor 里面的this指向实例对象, 方法里面的this 指向这个方法的调用者==**



# 第二章、构造函数和原型

## 2.1、构造函数和原型

### 2.1.1、概述

在典型的 OOP 的语言中（如 Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6之前， JS 中并没用引入类的概念。

ES6， 全称 ECMAScript 6.0 ，2015.06 发版。但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。

在 ES6之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。

创建对象可以通过以下三种方式：

1. 对象字面量
2. new Object()
3. 自定义构造函数

~~~javascript
<script>
        // 1 利用new object() 创建对象
        var obj1 = new Object;
        // 2 利用对象字面量创建对象
        var obj2 = {};
        // 3 利用构造函数创建对象
        function Star(uname,age) {
            this.uname = uname;
            this.age = age;
            this.sing = function() {
                console.log('~~~');
            }
        }
        var ldh = new Star('刘德华,18');
        console.log(ldh);
        ldh.sing();
    </script>
~~~



### 2.1.2、构造函数

**==构造函数==**是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

在 JS 中，使用构造函数时要注意以下两点：

1. 构造函数用于创建某一类对象，其==首字母要大写==
2. 构造函数要==和 new 一起使用==才有意义

> new在执行时会做四件事情：
>
> 1. 在内存中创建一个新的空对象。
> 2. 让 this 指向这个新的对象。
> 3. 执行构造函数里面的代码，给这个新对象添加属性和方法。
> 4. 返回这个新对象（所以构造函数里面不需要 return ）。

JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为==静态成员==和==实例成员==。

- 静态成员：在构造函数本上添加的成员称为==静态成员，只能由构造函数本身来访问==
- 实例成员：在构造函数内部创建的对象成员称为==实例成员，只能由实例化的对象来访问==

### 2.1.3、构造函数的问题

构造函数方法很好用，但是==存在浪费内存的问题==。

~~~javascript
function Star(uname, age) {
    this.uname = uname;
    this.age = age;
    this.sing = function() {
        console.log('我会唱歌');}
}
var ldh = new Star('刘德华', 18);
var zxy = new Star('张学友', 19);
~~~

<img src="E:\笔记\图片\微信截图_20221128104017.png" style="zoom:80%;" />

### 2.1.4、构造函数原型prototype

构造函数通过原型分配的函数是所有对象所==**共享的**==。

JavaScript 规定，==每一个构造函数都有一个 prototype 属性==，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。

> 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。

![](E:\笔记\图片\微信截图_20221128104417.png)

~~~javascript
<script>
        // 构造函数的问题
        function Star(uname,age) {
            this.uname = uname;
            this.age = age;
            // this.sing = function() {
            //     console.log('i am iron man');
            // }
        }
        Star.prototype.sing = function() {
            console.log('我会唱歌');
        }
        var ldh = new Star('刘德华', 18);
        var zxy = new Star('张学友', 19);
        console.log(ldh.sing === zxy.sing);
        // console.dir(Star);
        ldh.sing();
        zxy.sing();
        // 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上
    </script>
~~~

### 2.1.5、对象原型

~~~javascript
对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。

__proto__对象原型和原型对象 prototype 是等价的

__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype

~~~

<img src="E:\笔记\图片\微信截图_20221128104923.png" style="zoom:80%;" />

~~~javascript
<script>
        function Star(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        Star.prototype.sing = function() {
            console.log('我会唱歌');
        }
        var ldh = new Star('刘德华', 18);
        var zxy = new Star('张学友', 19);
        ldh.sing();
        console.log(ldh); // 对象身上系统自己添加一个 __protp__ 指向我们构造函数的原型对象prototy
        console.log(ldh.__proto__ == Star.prototype);
        // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing
        // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法
    </script>
~~~



### 2.1.6、constructor构造函数

对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性，constructor 我们称为构造函数，因为==它指回构造函数本身==。

> constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。

==一般情况下，对象的方法都在构造函数的原型对象中设置==。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。

### 2.1.7、构造函数、实例、原型对象三者之间的关系

<img src="E:\笔记\图片\微信截图_20221128110905.png" style="zoom:80%;" />

### 2.1.8、原型链

![](E:\笔记\图片\微信截图_20221128111329.png)

### 2.1.9、JavaScript的成员查找机制（规则）

1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
2. 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。
3. 如果还没有就查找原型对象的原型（Object的原型对象）。
4. 依此类推一直找到 Object 为止（null）。
5. __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。

### 2.1.10、原型对象this指向

构造函数中的this 指向我们实例对象.

==原型对象==里面放的是方法, 这个方法==里面的this 指向==的是 这个方法的调用者, 也就是这个==实例对象==.

~~~javascript
<script>
        function Star(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        var that;
        Star.prototype.sing = function() {
            console.log('我会唱歌');
            that = this;
        }
        var ldh = new Star('刘德华', 18);
        // 1. 在构造函数中,里面this指向的是对象实例 ldh
        ldh.sing();
        console.log(that === ldh);  // true
        // 2.原型对象函数里面的this 指向的是 实例对象 ldh
    </script>
~~~

### 2.1.11、扩展内置对象

可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。

~~~javascript
<script>
        // 原型对象的应用 扩展内置对象方法
        Array.prototype.sum = function() {
            var sum = 0;
            for(var i = 0;i < this.length;i++) {
                sum += this[i];
            }
            return sum;
        };
         // Array.prototype = {
        //     sum: function() {
        //         var sum = 0;
        //         for (var i = 0; i < this.length; i++) {
        //             sum += this[i];
        //         }
        //         return sum;
        //     }

        // }
        var arr = [1, 2, 3];
        console.log(arr.sum());
        console.log(Array.prototype);
        var arr1 = new Array(11,22,33);
        console.log(arr1.sum());
    </script>
~~~

> 注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。



## 2.2、继承

ES6之前并没有给我们提供 extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。

### 2.2.1、call()

调用这个函数，并且修改函数运行时的this指向

~~~javascript
fun.call(thisArg, arg1, arg2, ...) 
~~~

- thisArg ：当前调用函数 this 的指向对象
- arg1，arg2：传递的其他参数

~~~javascript
<script>
        // call 方法
        function fn(x,y) {
            console.log('我想喝手磨咖啡');
            console.log(this);
            console.log(x + y);
        }
        var o = {
            name:'andy'
        };
        // fn();
        //1. call() 可以调用函数
        // fn.call();
        // 2.call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象   
        fn.call(o,1,2);
    </script>
~~~

### 2.2.2、借用构造函数继承父类型属性

> 核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。  

~~~javascript
<script>
        // 借用父构造函数继承属性
        // 1. 父构造函数
        function Father(uname,age) {
            // this 指向父构造函数的对象实例
            this.uname = uname;
            this.age = age;
        }
        // 2 .子构造函数
        function Son(uname,age,score) {
            // this 指向子构造函数的对象实例
            Father.call(this,uname,age);
            this.score = score;
        }
        var son = new Son('刘德华',18,100)
        console.log(son);
    </script>
~~~

### 2.2.3、借用原型对象继承父类型方法

一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。 

核心原理：

1. 将子类所共享的方法提取出来，让子类的 ==prototype 原型对象 = new 父类()==
2. 本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象
3. 将子类的 constructor 从新指向子类的构造函数

<img src="E:\笔记\图片\微信截图_20221128154714.png" style="zoom:80%;" />

~~~javascript
<script>
        // 借用父构造函数继承属性
        // 1. 父构造函数
        function Father(uname, age) {
            // this 指向父构造函数的对象实例
            this.uname = uname;
            this.age = age;
        }
        Father.prototype.money = function() {
            console.log(100000);

        };
        // 2 .子构造函数 
        function Son(uname, age, score) {
            // this 指向子构造函数的对象实例
            Father.call(this, uname, age);
            this.score = score;
        }
        // Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化
        Son.prototype = new Father();
        // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数
        Son.prototype.constructor = Son;
        // 这个是子构造函数专门的方法
        Son.prototype.exam = function() {
            console.log('孩子要考试');

        }
        var son = new Son('刘德华', 18, 100);
        console.log(son);
        console.log(Father.prototype);
        console.log(Son.prototype.constructor);
    </script>
~~~



## 2.3、类的本质

1. class本质还是function.
2. 类的所有方法都定义在类的prototype属性上
3. 类创建的实例,里面也有__proto__ 指向类的prototype原型对象
4. 所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
5. 所以ES6的类其实就是语法糖.
6. 语法糖:语法糖就是一种便捷写法.  简单理解, 有两种方法可以实现同样的功能, 但是一种写法更加清晰、方便,那么这个方法就是语法糖

~~~javascript
<script>
        // ES6 之前通过 构造函数+ 原型实现面向对象 编程
        // (1) 构造函数有原型对象prototype 
        // (2) 构造函数原型对象prototype 里面有constructor 指向构造函数本身
        // (3) 构造函数可以通过原型对象添加方法
        // (4) 构造函数创建的实例对象有__proto__ 原型指向 构造函数的原型对象
        // ES6 通过 类 实现面向对象编程 
        class Star {

        }
        console.log(typeof Star);
        // 1. 类的本质其实还是一个函数 我们也可以简单的认为 类就是 构造函数的另外一种写法
        // (1) 类有原型对象prototype 
        console.log(Star.prototype);
        // (2) 类原型对象prototype 里面有constructor 指向类本身
        console.log(Star.prototype.constructor);
        // (3)类可以通过原型对象添加方法
        Star.prototype.sing = function() {
            console.log('冰雨');

        }
        var ldh = new Star();
        console.dir(ldh);
        // (4) 类创建的实例对象有__proto__ 原型指向 类的原型对象
        console.log(ldh.__proto__ === Star.prototype);

    </script>
~~~



## 2.4、ES5新增方法概述

ES5 中给我们新增了一些方法，可以很方便的操作数组或者字符串，这些方法主要包括：

- 数组方法
- 字符串方法
- 对象方法

### 2.4.1、数组方法

迭代(遍历)方法：forEach()、map()、filter()、some()、every()；

#### 2.4.1.1、forEach()

语法：

~~~javascript
array.forEach(function(currentValue, index, arr))
~~~

- currentValue：数组当前项的值
- index：数组当前项的索引
- arr：数组对象本身

~~~javascript
<script>
        // forEach 迭代（遍历） 数组
        var arr = [1,2,3];
        var sum = 0;
        arr.forEach(function(value,index,array) {
            console.log('每个数组元素' + value);
            console.log('每个数组元素的索引号' + index);
            console.log('数组本身' + array);
            sum += value;
        })
        console.log(sum);
    </script>
~~~

#### 2.4.1.2、filter()

语法：

~~~javascript
array.filter(function(currentValue, index, arr))
~~~

- currentValue: 数组当前项的值
- index：数组当前项的索引
- arr：数组对象本身

> - filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组
>
> - l注意它直接返回一个新数组

~~~javascript
<script>
        // filter筛选数组
        var arr = [12,66,4,88,3,7];
        var newArr = arr.filter(function(value,index) {
            // return vlaue >= 20;
            return value % 2 == 0;
        })
        console.log(newArr);
    </script>
~~~

#### 2.4.1.3、some()

语法：

~~~javascript
array.some(function(currentValue, index, arr))
~~~

- currentValue: 数组当前项的值
- index：数组当前项的索引
- arr：数组对象本身

> - some() 方法用于检测数组中的元素是否满足指定条件.  通俗点 查找数组中是否有满足条件的元素。
> - 注意它返回值是布尔值, 如果查找到这个元素, 就返回true ,  如果查找不到就返回false。
> - 如果找到第一个满足条件的元素,则终止循环. 不在继续查找。

~~~javascript
<script>
        // some 查找数组中是否有满足条件的元素
        // var arr = [10,30,40];
        // var flag = arr.some(function(value) {
        //     // return value >= 20;
        //     return value < 3;

        // });
        // console.log(flag);
        var arr1 = ['red','brown','cony'];
        var flag1 = arr1.some(function(value) {
            return value == 'brown';
        });
        console.log(flag1);
        // 1. filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来
        // 2. some 也是查找满足条件的元素是否存在  返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环
    </script>
~~~

### 2.4.2、字符串方法

#### 2.4.1.1、trim()

trim() 方法会从一个字符串的两端删除空白字符。

语法：

~~~javascript
str.trim()
~~~

trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。

~~~~javascript
<script>
        // trim 方法去除字符串两侧空格
        var str = '   andy  ';
        var str1 = str.trim();
        console.log(str1);
        var input = document.querySelector('input');
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        btn.onclick = function() {
            var str = input.value.trim();
            if(str === ''){
                alert('请输入内容')
            }else {
                div.innerHTML = str;
            }
        }
    </script>
~~~~

### 2.4.3、对象方法

#### 2.4.3.1、Object.keys()

Object.keys() 用于获取对象自身所有的属性

语法：

~~~javascript
Object.keys(obj)
~~~

- 效果类似 for…in
- 返回一个由属性名组成的数组

~~~javascript
<script>
        // 用于获取对象自身所有属性
        var obj = {
            id:1,
            pname:'小米',
            price:1999,
            num:2000
        };
        var arr = Object.keys(obj);
        console.log(arr);
        arr.forEach(function(value) {
            console.log(value);
        })
    </script>
~~~

#### 2.4.3.2、Object.defineProperty()

Object.defineProperty() 定义新属性或修改原有的属性。

语法：

~~~javascript
Object.defineProperty(obj, prop, descriptor)
~~~

- obj：必需。目标对象 
- prop：必需。需定义或修改的属性的名字
- descriptor：必需。目标属性所拥有的特性

> Object.defineProperty()  第三个参数 descriptor 说明： 以对象形式 { } 书写
>
> - value: 设置属性的值 默认为undefined
> - writable: 值是否可以重写。true | false 默认为false
> - enumerable: 目标属性是否可以被枚举。true | false 默认为 false
> - configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false 默认为false



# 第三章、函数进阶

## 3.1、函数的定义和调用

### 3.1.1、函数的定义方式

1. 函数声明方式 function 关键字 （命名函数）

2. 函数表达式（匿名函数）

3. new Function()

   `var fn = new Function('参数1','参数2'..., '函数体')`

- Function 里面参数都必须是字符串格式
- 第三种方式执行效率低，也不方便书写，因此较少使用
- 所有函数都是 Function 的实例(对象)
- 函数也属于对象

~~~javascript
<script>
        //  函数的定义方式

        // 1. 自定义函数(命名函数) 
        function fn() {};
        // 2. 函数表达式
        var fun = function() {};
        // 3. 利用 new Function('参数1','参数2', '函数体'); 
        var  f = new Function('a','b','console.log(a + b)');
        f(1,2);
        // 4. 所有函数都是Function 的实例（对象）
        console.dir(f);
        // 函数也属于对象
        console.log(f instanceof Object);
    </script>
~~~

<img src="E:\笔记\图片\微信截图_20221130005317.png" style="zoom:90%;" />

### 3.1.2、函数的调用方式

1. 普通函数
2. 对象的方法
3. 构造函数
4. 绑定事件函数
5. 定时器函数
6. 立即执行函数

~~~javascript
<script>
        // 函数的调用方式
        // 1.普通函数
        function fn() {
            console.log('卡面来打~');
        }
        fn();
        fn.call();

        // 2.对象的方法
        var o = {
            sayHi:function() {
                console.log();
            }
        };
        o.sayHi();

        // 3.构造函数
        function Star() {};
        new Star();

        // 4 绑定事件函数
        // btn.onclick function() {};  点击了按钮就可以调用这个函数

        // 5. 定时器函数
        // serInterval(funciton() {},1000);  这个函数时定时器自动一秒钟调用一次

        // 6.立即执行函数
        (function() {
            console.log('卡面来打~');
        })();
        // 立即执行函数时自动调用
    </script>
~~~

## 3.2、this

### 3.2.1、函数内this的指向

这些 this 的指向，是当我们调用函数的时候确定的。 调用方式的不同决定了this 的指向不同

一般指向我们的调用者

| 调用方式     | this指向                                  |
| ------------ | ----------------------------------------- |
| 普通函数调用 | window                                    |
| 构造函数调用 | 实例对象 原型对象里面的方法也指向实例对象 |
| 对象方法调用 | 该方法所属对象                            |
| 事件绑定方法 | 绑定事件对象                              |
| 定时器函数   | window                                    |
| 立即执行函数 | window                                    |

~~~javascript
<body>
    <button>点击</button>
    <script>
        // 函数的不同调用方式决定了this 的指向不同
        // 1.普通函数 this 指向 window
        function fn () {
            console.log('普通函数的this' + this);
        }
        window.fn();
        // 2. 对象的方法 this指向的是对象 o
        var o = {
            sayHi:function() {
                console.log('对象方法的this:' + this);
            }
        }
        o.sayHi();
        // 3. 构造函数 this 指向 ldh 这个实例对象 原型对象里面的this 指向的也是 ldh这个实例对象
        function Star() {
            Star.prototype.sing = function() {

            }
        }
        var ldh = new Star();
        // 4. 绑定事件函数 this指向的时候函数的调用者 btn这个按钮对象
        var btn = document.querySelector('button');
        btn.addEventListener('click',function() {
            console.log('绑定时间函数的this'+ this);
        });

        //6.定时器函数 this 指向的也是window
        window.setTimeout(function() {
            console.log('定时器的this:' + this);
        },1000); 

        // 6. 立即执行函数 this 还是指向window
        (function() {
            console.log('立即执行函数this' + this);
        })();
    </script>
</body>
~~~

### 3.2.2、改变函数内部this指向

JavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部 this 的指向问题，常用的有 bind()、call()、apply() 三种方法。

#### 3.2.2.1、call方法

call()方法==调用==一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。

语法：

`fun.call(thisArg, arg1, arg2, ...) `

- thisArg：在 fun 函数运行时指定的 this 值
- arg1，arg2：传递的其他参数
- 返回值就是函数的返回值，因为它就是调用函数
- 因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承

~~~JavaScript
<script>
        // 改变函数内this指向  js提供了三种方法  call()  apply()  bind()
        // 1. call()
        var o = {
            name: 'andy'
        }

        function fn(a, b) {
            console.log(this);
            console.log(a + b);

        };
        fn.call(o,1,2);
        // call 第一个可以调用函数 第二个可以改变函数内的this 指向
        // call 的主要作用可以实现继承
        function Father(uname, age, sex) {
            this.uname = uname;
            this.age = age;
            this.sex = sex;
        }
        function Son(uname,age,sex) {
            Father.call(this,uname,age,sex);
        }
        var son = new Son('程朗',18,'man');
        console.log(son);
    </script>
~~~

#### 3.2.2.2、apply方法

apply() 方法==调用==一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。

语法：

`fun.apply(thisArg, [argsArray])`

- thisArg：在fun函数运行时指定的 this 值
- argsArray：传递的值，必须包含在==数组==里面
- 返回值就是函数的返回值，因为它就是调用函数
- 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值

~~~javascript
<body>
    <script>
        // 改变函数内this指向  js提供了三种方法  call()  apply()  bind()
        // 2. apply()  应用 运用的意思
        var o = {
            name: 'andy'
        };

        function fn(arr) {
            console.log(this);
            console.log(arr); // 'pink'

        };
        fn.apply(o, ['pink']);
        // 1. 也是调用函数 第二个可以改变函数内部的this指向
        // 2. 但是他的参数必须是数组(伪数组)
        // 3. apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 
        // Math.max();
        var arr = [1, 66, 3, 99, 4];
        var arr1 = ['red', 'pink'];
        var max = Math.max.apply(null,arr);
        var max = Math.max.apply(Math,arr);
        var min = Math.min.apply(Math,arr);
        console.log(max,min);
    </script>
</body>
~~~

#### 3.2.2.3、bind方法

bind() 方法不会调用函数。但是能改变函数内部this 指向

`fun.bind(thisArg, arg1, arg2, ...)`

- thisArg：在 fun 函数运行时指定的 this 值
- arg1，arg2：传递的其他参数
- 返回由指定的 this 值和初始化参数改造的原函数拷贝
- 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind

~~~javascript
<body>
    <button>点击</button>
    <button>点击</button>
    <button>点击</button>
    <script>
        // 改变函数内this指向  js提供了三种方法  call()  apply()  bind()
        // 3. bind()  绑定 捆绑的意思
        var o = {
            name: 'andy'
        };

        function fn(a, b) {
            console.log(this);
            console.log(a + b);
        };
        var f = fn.bind(o,1,2);
        f();
        // 1. 不会调用原来的函数   可以改变原来函数内部的this 指向
        // 2. 返回的是原函数改变this之后产生的新函数
        // 3. 如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind
        // 4. 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮
        // var btn1 = document.querySelector('button');
        // btn1.onclick = function() {
        //     this.disabled = true; // 这个this 指向的是 btn 这个按钮
        //     // var that = this;
        //     setTimeout(function() {
        //         // that.disabled = false; // 定时器函数里面的this 指向的是window
        //         this.disabled = false; // 此时定时器函数里面的this 指向的是btn
        //     }.bind(this), 3000); // 这个this 指向的是btn 这个对象
        // }
        var btns = document.querySelectorAll('button');
        for(var i = 0;i <btns.length;i++) {
            btns[i].onclick = function() {
                this.disabled = true;
                setTimeout(function(){
                    this.disabled = false;
                }.bind(this),3000);
            }
        }
    </script>
~~~

#### 3.3.2.4、call，apply，bind 总结

**相同点：**

都可以改变函数内部的this指向

**区别点：**

1. call 和 apply 会调用函数, 并且改变函数内部this指向。
2. call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式[arg]。
3. bind 不会调用函数, 可以改变函数内部this指向。

**主要应用场景**

1. call经常做继承
2. apply经常跟数组有关系，比如借助于数学对象实现数组最大值最小值
3. bind 不调用函数，但是可以改变this指向，比如改变定时器内部的this指向



## 3.3、严格模式

### 3.3.1、什么是严格模式

JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。

严格模式对正常的 JavaScript 语义做了一些更改： 

1. 消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。
2. 消除代码运行的一些不安全之处，保证代码运行的安全。
3. 提高编译器效率，增加运行速度。
4. 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class, enum, export, extends, import, super 不能做变量名

### 3.3.2、开启严格模式

严格模式可以应用到==整个脚本==或==个别函数==中。因此在使用时，我们可以将严格模式分==为为脚本开启严格模式==和==为函数开启严格模式==两种情况。

#### 3.3.2.1、为脚本开启严格模式

为整个脚本文件开启严格模式，需要==在所有语句之前放一个特定语句“use strict”;（或‘use strict’;）==。

~~~javascript
<script>
　　"use strict";
　　console.log("这是严格模式。");
</script>
~~~

> 因为"use strict"加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。

有的 script 基本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他 script 脚本文件。

~~~JavaScript
<script>
  (function (){
　　　　"use strict";
       var num = 10;
　　　　function fn() {}
　  })();
</script>
~~~

#### 3.2.2.2、为函数开启严格模式

要给某个函数开启严格模式，需要==把“use strict”; (或 'use strict'; ) 声明放在函数体所有语句之前==。

~~~javascript
function fn(){
　　"use strict";
　　return "这是严格模式。";
}
~~~

将 "use strict" 放在函数体的第一行，则整个函数以 "严格模式" 运行。

### 3.3.3、严格模式中的变化

严格模式对 Javascript 的语法和行为，都做了一些改变。

#### 3.3.3.1、变量规定

1. 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用。
2. 严禁删除已经声明变量。例如，delete x; 语法是错误的。

#### 3.3.3.2、严格模式下this指向问题

1. 以前在全局作用域函数中的 this 指向 window 对象。
2. 严格模式下全局作用域中函数中的 this 是 undefined。
3. 以前构造函数时不加 new也可以 调用,当普通函数，this 指向全局对象。
4. 严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错。
5. new 实例化的构造函数指向创建的对象实例。
6. 定时器 this 还是指向 window。
7. 事件、对象还是指向调用者。

#### 3.3.3.3、函数变化

1. 函数不能有重名的参数。
2. 函数必须声明在顶层.新版本的 JavaScript 会引入“块级作用域”（ ES6 中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。 

> 更多严格模式要求参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode



## 3.4、高阶函数

**高阶函数**是对其他函数进行操作的函数，它==接收函数作为参数==或==将函数作为返回值输出==。

~~~javascript
<script>
function fn(callback){
  callback&&callback();
}
fn(function(){alert('hi')}
</script>
~~~

~~~javascript
<script>
function fn(){
    return function() {}
}
 fn();
</script>
~~~

此时fn 就是一个高阶函数

函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。 最典型的就是作为回调函数。

同理函数也可以作为返回值传递回来

## 3.5、闭包

### 3.5.1、变量的作用域

变量根据作用域的不同分为两种：全局变量和局部变量。

1. 函数内部可以使用全局变量。
2. 函数外部不可以使用局部变量。
3. 当函数执行完毕，本作用域内的局部变量会销毁。

### 3.5.2、什么是闭包

==闭包（closure）==指有权访问另一个函数作用域中变量的函数。 ----- JavaScript 高级程序设计

简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。

~~~javascript
<script>
 function fn1(){    // fn1 就是闭包函数
　　　　var num = 10;
　　　　function fn2(){
　　　　　　console.log(num); // 10
　　　　}
       fn2()
　}
  fn1();
</script>
~~~

### 3.5.3、在chrome中调试闭包

1. 打开浏览器，按 F12 键启动 chrome 调试工具
2. 设置断点
3. 找到Scope选项（Scope 作用域的意思）
4. 当我们重新刷新页面，会进入断点调试，Scope 里面会有两个参数（global 全局作用域、local 局部作用域）
5. 当执行到 fn2() 时，Scope 里面会多一个 Closure 参数 ，这就表明产生了闭包

### 3.5.4、闭包的作用

提问：我们怎么能再fn()函数外面访问fn()中的局部变量num呢？

~~~javascript
<script>
 function fn() {　　　　
    var num = 10;　　　　
    return function {　　　　　　
         console.log(num); // 10         　　　　
     }
  }
  var f = fn();
  f()
</script>
~~~

> 闭包的作用：延伸变量的作用范围。



## 3.6、递归

### 3.6.1、什么是递归

如果==一个函数在内部可以调用其本身==，那么这个函数就是==递归函数==。

简单理解:函数内部自己调用自己, 这个函数就是递归函数

递归函数的作用和循环效果一样

由于递归很容易发生“栈溢出”错误（stack overflow），所以==必须要加退出条件 return==。

### 3.6.2、利用递归求数学题

1. 求 1 * 2 *3 ... * n  阶乘

   ~~~javascript
   <script>
           // 利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n
           function fn(n) {
               if (n == 1) {
                   return 1;
               }
               return n * fn(n - 1);
           }
           console.log(fn(3));
           console.log(fn(4));
           // 详细思路 假如用户输入的是3
           //return  3 * fn(2)
           //return  3 * (2 * fn(1))
           //return  3 * (2 * 1)
           //return  3 * (2)
           //return  6
       </script>
   ~~~

2. 求斐波那契数列

   ~~~javascript
   <script>
           // 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...
           // 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值
           // 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值
           function fb(n) {
               if (n === 1 || n === 2) {
                   return 1;
               }
               
               return fb(n - 1) + fb(n - 2);
           }
           console.log(fb(3));
           console.log(fb(6));
       </script>
   ~~~

### 3.6.3、浅拷贝和深拷贝

如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝；如果B没变，那就是深拷贝，深拷贝与浅拷贝的概念只存在于引用数据类型。

1. 浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用
2. 深拷贝拷贝多层, 每一级别的数据都会拷贝
3. `Object.assign(target, ...sources)` ==es6 新增方法可以浅拷贝==

~~~javascript
<script>
        // 浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用.
        // 深拷贝拷贝多层, 每一级别的数据都会拷贝.
        var obj = {
            id: 1,
            name: 'andy',
            msg: {
                age: 18
            }
        };
        var o = {};
        // for (var k in obj) {
        //     // k 是属性名   obj[k] 属性值
        //     o[k] = obj[k];
        // }
        // console.log(o);
        // o.msg.age = 20;
        // console.log(obj);

        console.log('--------------');
        Object.assign(o, obj);
        console.log(o);
        o.msg.age = 20;
        console.log(obj);
    </script>
~~~



# 第四章、正则表达式

## 4.1、正则表达式概述

**正则表达式（** Regular Expression **）**是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。

正则表通常被用来检索、替换那些符合某个模式（规则）的文本。

例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(==匹配==)

此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(==替换==)

或从字符串中获取我们想要的特定部分(==提取==)等 

正则表达式的特点：

- 灵活性、逻辑性和功能性非常的强。

- 可以迅速地用极简单的方式达到字符串的复杂控制。

- 对于刚接触的人来说，比较晦涩难懂。比如： ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$

- 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式.  

  比如用户名:  /^[a-z0-9_-]{3,16}$/

## 4.2、正则表达式在JavaScript中的使用

### 4.2.1、创建正则表达式

在 JavaScript 中，可以通过两种方式创建一个正则表达式。

#### 4.2.1.1、通过调用RegExp对象的构造函数创建

语法：

`var 变量名 = new RegExp(/表达式/); `

~~~javascript
// / 1. 利用 RegExp对象来创建 正则表达式
        var reg = new RegExp(/123/);
        console.log(reg);
~~~

#### 4.2.1.2、通过字面量创建

语法：

`var 变量名 = /表达式/; `

~~~javascript
// 2. 利用字面量创建 正则表达式
        var rg = /123/;
~~~

> // 注释中间放表达式就是正则字面量

### 4.2.2、测试正则表达式test

test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。

语法：

~~~javascript
regexObj.test(str);
~~~

- regexObj 是写的正则表达式
- str 我们要测试的文本
- 就是检测str文本是否符合我们写的正则表达式规范

~~~javascript
var rg = /123/;
console.log(rg.test(123));
console.log(rg.test('abc'));
~~~



## 4.3、正则表达式中的特殊字符

一个正则表达式==可以由简单的字符构成==，比如 /abc/，==也可以是简单和特殊字符的组合==，比如 /ab*c/ 。其中特殊字符也被称为==元字符==，在正则表达式中是具有==特殊==意义的专用==符号==，如 ^ 、$ 、+ 等。

特殊字符非常多，可以参考：

- MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions
- jQuery 手册：正则表达式部分
- 正则测试工具: http://tool.oschina.net/regex

### 4.3.1、边界符

正则表达式中的边界符（位置符）用来==提示字符所处的位置==，主要有两个字符。

| 边界符 | 说明                           |
| ------ | ------------------------------ |
| ^      | 表示匹配行首的文本（以谁开始） |
| $      | 表示匹配行尾的文本（以谁结束） |

> 如果 ^ 和 $ 在一起，表示必须是精确匹配。

~~~javascript
<script>
        // 边界符 ^ $ 
        var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型
        // /abc/ 只要包含有abc这个字符串返回的都是true
        console.log(rg.test('abc')); // true
        console.log(rg.test('abcd')); // true
        console.log(rg.test('aabcd')); // true
        console.log('---------------------------');
        var reg = /^abc/;
        console.log(reg.test('abc')); // true
        console.log(reg.test('abcd')); // true
        console.log(reg.test('aabcd')); // false
        console.log('---------------------------');
        var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范
        console.log(reg1.test('abc')); // true
        console.log(reg1.test('abcd')); // false
        console.log(reg1.test('aabcd')); // false
        console.log(reg1.test('abcabc')); // false
    </script>
~~~

### 6.3.2、字符类

字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。==所有可供选择的字符都放在方括号内==。

1. [] 方括号

   ```javascript
   /[abc]/.test('andy')     // true 
   ```

   > 后面的字符串只要包含 abc 中任意一个字符，都返回 true 。

2. [-] 方括号内部 范围符 -

   ~~~javascript
   /^[a-z]$/.test('c')     // true
   ~~~

   方括号内部加上 - 表示范围，这里表示 a 到 z 26个英文字母都可以。		

3. [^] 方括号内部 取反符^  

   ~~~javascript
   /[^abc]/.test('andy')     // false
   ~~~

   方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。

   > 注意和边界符 ^ 区别，边界符写到方括号外面。 

4. 字符组合

   ~~~javascript
   /[a-z1-9]/.test('andy')     // true
   ~~~

   方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。

### 6.3.3、量词符

量词符用来设定某个模式出现的次数

| 量词  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ？    | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |

~~~javascript
<script>
        var reg = /^a*$/;
        console.log(reg.test(''));  // true
        console.log(reg.test('a')); // true
        console.log(reg.test('aaaa')); // true
        console.log('------------------');

        var reg = /^a{3}$/;
        console.log(reg.test('')); // false
        console.log(reg.test('a')); // false
        console.log(reg.test('aaa')); // true
        console.log('------------------');

        var reg = /^a{3,}$/;
        console.log(reg.test('')); // false
        console.log(reg.test('a')); // false
        console.log(reg.test('aaa')); // true
        console.log(reg.test('aaaaaa')); // true
    </script>
~~~

### 6.3.4、括号总结

1. 大括号 量词符。里面表示重复次数

   ~~~javascript
   // 大括号  量词符. 里面表示重复次数
            var reg = /^abc{3}$/; // 它只是让c重复三次   abccc
            console.log(reg.test('abc'));
            console.log(reg.test('abcabcabc'));
            console.log(reg.test('abccc'));
   ~~~

2. 中括号 字符集和。匹配方括号中的任意字符

   ~~~javascript
   // 中括号 字符集合.匹配方括号中的任意字符.
   var reg = /^[abc]$/;
   // a 也可以 b 也可以 c 可以  a || b || c
   ~~~

3. 小括号 表示优先级

   ~~~javascript
   // 小括号 表示优先级
           var reg = /^(abc){3}$/; // 它是让abcc重复三次
           console.log(reg.test('abc'));  // false
           console.log(reg.test('abcabcabc')); //true
           console.log(reg.test('abccc')); // false
   ~~~



### 6.3.5、预定义类

预定义类指的是某些常见模式的简写方式。

| 预定类 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| \d     | 匹配0-9之间的任一数字，相当于[0-9]                           |
| \D     | 匹配所有0-9以外的字符，相当于[ ^ 0-9]                        |
| \w     | 匹配任意的字符，数字和下划线 ，相当于[A-Za-z0-9]             |
| \W     | 除所有字母、数字和下划线以外的字符，相当于[ ^A-Za-z0-9_]     |
| \s     | 匹配空格（包括换行符、制表符、空格符等）、相等于[\t\r\n\v\f] |
| \S     | 匹配非空格的字符，相当于[ ^\t\r\n\v\f]                       |

> 正则里面的或者 符号  |（一个竖线）。



## 4.4、正则表达式中的替换

### 4.4.1、replace 替换

replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。

~~~javascript
stringObject.replace(regexp/substr,replacement)
~~~

1. 第一个参数:  被替换的字符串 或者 正则表达式
2. 第二个参数:  替换为的字符串
3. 返回值是一个替换完毕的新字符串

~~~javascript
<body>
    <textarea name="" id="message"></textarea> <button>提交</button>
    <div></div>
    <script>
        // 替换 replace
        var str = 'andy和red';
        // var newArr = str.replace('andy','baay');
         var newArr = str.replace(/andy/,'baby');
         console.log(newArr);
         var text = document.querySelector('textarea');
         var btn = document.querySelector('button');
         var div = document.querySelector('div');
         btn.onclick = function() {
            div.innerHTML = text.value.replace(/激情|gay/g,'**');
         }  
    </script>
</body>
~~~

### 4.4.2、正则表达式参数

~~~javascript
/表达式/[switch]
~~~

switch(也称为修饰符) 按照什么样的模式来匹配. 有三种值：

- g：全局匹配 
- i：全局匹配 
- gi：全局匹配 + 忽略大小写



# 第五章、ES6

## 5.1、ES6简介

ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的==一项脚本语言的标准化规范==。

| 年份      | 版本   |
| --------- | ------ |
| 2015年6月 | ES2015 |
| 2016年6月 | ES2016 |
| 2017年6月 | ES2017 |
| 2018年6月 | ES2018 |
| …         | …      |

> ES6 实际上是一个泛指，泛指 ES2015 及后续的版本。 

## 5.2、ECMASript 6 新特性

### 5.2.1、let关键字

ES6中新增的用于声明变量的关键字。

1. let声明的变量只在所处的块级有效

   ~~~javascript
   if (true) { 
        let a = 10;
   } 
   console.log(a) // a is not defined
   ~~~

   > 注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。

2. 不存在变量提升

   ~~~javascript
   console.log(a); // a is not defined 
    let a = 20;
   ~~~

3. 暂时性死区

   ~~~javascript
   var tmp = 123;
    if (true) { 
        tmp = 'abc';
        let tmp;
   }
   ~~~

4. let经典面试题

   ~~~javascript
   let arr = [];
    for (let i = 0; i < 2; i++) {
        arr[i] = function () {
            console.log(i); 
        }
    }
    arr[0]();
    arr[1]();
   ~~~

   <img src="E:\笔记\图片\微信截图_20221201164438.png" style="zoom:80%;" />

   > 经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值

   ---

   ~~~javascript
   let arr = [];
    for (let i = 0; i < 2; i++) {
        arr[i] = function () {
            console.log(i); 
        }
    }
    arr[0]();
    arr[1]();
   ~~~

   <img src="E:\笔记\图片\微信截图_20221201164438.png" style="zoom:80%;" />

   > 经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值



### 5.2.2、const关键字

作用：声明常量，常量就是值（内存地址）不能变化的量。

1. 具有块级作用域

   ~~~javascript
   if (true) { 
        const a = 10;
    }
   console.log(a) // a is not defined
   ~~~

2. 声明常量时必须赋值

   ~~~JavaScript
   const PI; // Missing initializer in const declaration
   ~~~

3. 常量赋值后，值不能修改

   ~~~javascript
   const PI = 3.14;
    PI = 100; // Assignment to constant variable. 
   ~~~

   > 对象属性修改和数组元素变化不会出发 const 错误。

   ~~~JavaScript
   const ary = [100, 200];
   ary[0] ='a';
   ary[1] ='b';
   console.log(ary); // ['a', 'b']; 
   ary = ['a', 'b']; // Assignment to constant variable.
   ~~~

   

### 5.2.3、let、const、var 的区别

1. 使用 ==var== 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。
2. 使用 ==let== 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。
3. 使用 ==const== 声明的是常量，在后面出现的代码中不能再修改该常量的值。

| var          | let            | const          |
| ------------ | -------------- | -------------- |
| 函数级作用域 | 块级作用域     | 块级作用域     |
| 变量提升     | 不存在变量提升 | 不存在变量提升 |
| 值可改变     | 值可改变       | 值不可改变     |

### 5.2.4、结构赋值

ES6中允许从数组中提取值，按照对应位置，对变量赋值。对象也可以实现解构。

按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。

#### 5.2.4.1、数组解构

~~~javascript
<script type="text/javascript">
		// 数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量
		let arr = [1,2,3];
		let [a,b,c] = arr;
		console.log(a); // 1
		console.log(b); // 2
		console.log(c); // 3
~~~

如果解构不成功，变量的值为undefined。

#### 5.2.4.2、对象解构

~~~javascript
let person = { name: 'zhangsan', age: 20 }; 
 let { name, age } = person;
 console.log(name); // 'zhangsan' 
 console.log(age); // 20

let {name: myName, age: myAge} = person; // myName myAge 属于别名
 console.log(myName); // 'zhangsan' 
 console.log(myAge); // 20
~~~

### 5.2.5、箭头函数

ES6中新增的定义函数的方式。

~~~JavaScript
() => {};
const fn = () => {};
~~~

1. 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号

   ~~~javascript
   function sum(num1, num2) { 
        return num1 + num2; 
    }
    const sum = (num1, num2) => num1 + num2; 
   ~~~

2. 如果形参只有一个，可以省略小括号

   ~~~javascript
   function fn (v) {
        return v;
    } 
    const fn = v => v;
   ~~~

3. 箭头函数不绑定this关键字，箭头函数中的this，指向的是==函数定义位置的上下文this==。

   ~~~javascript
   const obj = { name: '张三'} 
    function fn () { 
        console.log(this);
        return () => { 
            console.log(this)
        } 
    } 
    const resFn = fn.call(obj); 
    resFn();
   ~~~

   > 箭头函数 this 指向声明时所在作用域下 this 的值

### 5.2.6、rest参数

ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments

~~~JavaScript
 function sum (first, ...args) {
     console.log(first); // 10
     console.log(args); // [20, 30] 
 }
 sum(10, 20, 30)
// rest 参数必须是最后一个形参
~~~

> rest 参数非常适合不定个数参数函数的场景

### 5.2.7、. spread 扩展运算符

扩展运算符（spread）也是三个点（...）它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。

~~~JavaScript
let students = ['wangwu', 'zhangsan', 'lisi'];
 let [s1, ...s2] = students; 
 console.log(s1);  // 'wangwu' 
 console.log(s2);  // ['zhangsan', 'lisi']
~~~

### 5.2.8、Set数据结构

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

1. Set本身是一个构造函数，用来生成 Set 数据结构。

   ~~~JavaScript
   //创建一个空集合
   let s = new Set();
   //创建一个非空集合
   let s1 = new Set([1,2,3,1,2,3]);
   ~~~

2. Set函数可以接受一个数组作为参数，用来初始化。

   ~~~javascript
   const s1 = new Set([1, 2, 3, 4, 4]);
   ~~~

3. `Set.prototype.size`该属性可以返回该 Set 结构的元素个数。

   ~~~javascript
   <script>
           // 该属性可以返回该 Set 结构的元素个数。
           const s1 = new Set();
   		console.log(s1.size) // 0
   </script>
   ~~~

4. 实例方法：

   - add(value)：添加某个值，返回 Set 结构本身
   - delete(value)：删除某个值，返回一个布尔值，表示删除是否成功
   - has(value)：返回一个布尔值，表示该值是否为 Set 的成员
   - clear()：清除所有成员，没有返回值

   ~~~javascript
    const s = new Set();
    s.add(1).add(2).add(3); // 向 set 结构中添加值 
    s.delete(2)             // 删除 set 结构中的2值 
    s.has(1)                // 表示 set 结构中是否有1这个值 返回布尔值 
    s.clear()               // 清除 set 结构中的所有值
   ~~~

5. 遍历

   Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。

   ~~~JavaScript
   s.forEach(value => console.log(value))
   ~~~



### 5.2.9、Array的扩展方法

#### 5.2.9.1、扩展运算符（展开语法）

1. 扩展运算符可以将数组或者对象转为用逗号分隔的参数序列

   ~~~JavaScript
   let ary = [1, 2, 3];
    ...ary  // 1, 2, 3
    console.log(...ary);    // 1 2 3
    console.log(1, 2, 3)
   ~~~

2. 扩展运算符可以应用于==合并数组==。

   ~~~JavaScript
   // 方法一 
    let ary1 = [1, 2, 3];
    let ary2 = [3, 4, 5];
    let ary3 = [...ary1, ...ary2];
    // 方法二 
    ary1.push(...ary2);
   ~~~

3. 将类数组或可遍历对象转换为真正的数组

   ~~~JavaScript
   let oDivs = document.getElementsByTagName('div'); 
   oDivs = [...oDivs];
   ~~~

#### 5.2.9.2、构造函数的方法：Array.from()

1. 将类数组或可遍历对象转换为真正的数组

   ~~~javascript
   let arrayLike = {
       '0': 'a',
       '1': 'b',
       '2': 'c',
       length: 3
   }; 
   let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
   ~~~

2. 方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

   ~~~javascript
    let arrayLike = { 
        "0": 1,
        "1": 2,
        "length": 2
    }
    let newAry = Array.from(aryLike, item => item *2)
   ~~~

#### 5.2.9.3、实例方法：find()

1. 用于找出第一个符合条件的数组成员，如果没有找到返回undefined

   ~~~javascript
    let ary = [{
        id: 1,
        name: '张三‘
    }, { 
        id: 2,
        name: '李四‘
    }]; 
    let target = ary.find((item) => item.id == 2);
   ~~~

#### 5.2.9.4、实例方法：findIndex()

用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1

~~~JavaScript
let ary = [1, 5, 10, 15];
let index = ary.findIndex((value) => value > 9); 
console.log(index); // 2
~~~

#### 5.2.9.5、实例方法：includes()

表示某个数组是否包含给定的值，返回布尔值。

~~~javascript
[1, 2, 3].includes(2) // true 
[1, 2, 3].includes(4) // false
~~~



### 5.2.10、String 的扩展方法

#### 5.2.10.1、模板字符串

ES6新增的创建字符串的方式，使用反引号定义。

~~~javascript
let name = `zhangsan`;
~~~

模板字符串中可以==解析变量==。

~~~JavaScript
let name = '张三'; 
let sayHello = `hello,my name is ${name}`; // hello, my name is zhangsan
~~~

模板字符串中可以换行

~~~JavaScript
let result = { 
     name: 'zhangsan', 
     age: 20,      sex: '男' 
 } 
 let html = ` <div>
     <span>${result.name}</span>
     <span>${result.age}</span>
     <span>${result.sex}</span>
 </div> `;
~~~

在模板字符串中可以调用函数。

~~~JavaScript
const sayHello = function () { 
    return '哈哈哈哈 追不到我吧 我就是这么强大';
 }; 
let greet = `${sayHello()} 哈哈哈哈`;
console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈
~~~

#### 5.2.10.2、实例方法：startWith() 和 endsWith()

- lstartsWith()：表示参数字符串是否在原字符串的头部，返回布尔值
- lendsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值

~~~javascript
let str = 'Hello world!';
str.startsWith('Hello') // true 
str.endsWith('!')       // true
~~~

#### 5.2.10.3、实例方法：repeat()

repeat方法表示将原字符串重复n次，返回一个新字符串。

~~~JavaScript
'x'.repeat(3)      // "xxx" 
'hello'.repeat(2)  // "hellohello"
~~~



### 5.2.11、Symbol类型

ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。

Symbol特点：

1. Symbol 的值是唯一的，用来解决命名冲突的问题
2. Symbol 值不能与其他数据进行运算
3. Symbol 定义 的 对象属 性 不能 使 用 for…in 循 环遍 历 ，但 是可 以 使 用 Reflect.ownKeys 来获取对象的所有键名

~~~JavaScript
//创建 Symbol
let s1 = Symbol();
console.log(s1);
console.log(typeof s1);

//添加标识的 Symbol
let s2 = Symbol("张三");
let s2_2 = Symbol("张三");
console.log(s2);
console.log(s2_2);
console.log(s2 === s2_2);

//使用 Symbol for 定义
let s3 = Symbol.for("张三");
let s3_2 = Symbol.for("张三");
console.log(s3);
console.log(s3_2);
console.log(s3 === s3_2);

//在方法中使用 Symbol
let game = {
    name: "狼人杀",
    [Symbol('say')]: function () {
        console.log("我可以发言")
    },
    [Symbol('zibao')]: function () {
        console.log('我可以自爆');
    }
};
console.log(game);
~~~

<img src="E:\笔记\图片\微信截图_20221202012539.png" style="zoom:80%;" />

