[TOC]

# 第一章、Web API

## 1.1、Web APIs和JS基础关联性

<img src="E:\笔记\图片\微信截图_20221104111124.png" style="zoom:50%;" />

## 1.2、JS基础阶段以及Web APIs阶段

> JS基础阶段

- 我们学习的是ECMAscript标准规定的基本语法
- 要求同学们掌握JS基础语法
- 只学习基本语法，做不了常用的网页交互效果
- 目的是为了JS后面的课程打基础、做铺垫

> Web APIs 阶段
>
> - web APIs是w3c组织的标准
> - web APIs 我们主要学习DOM和BOM
> - web APIs 是我们JS所独有的部分
> - 我们主要学习页面交互功能
> - 需要使用JS基础的课程内容做基础

## 1.2、API

API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

> 简单理解：API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能

比如手机充电的接口：

<img src="E:\笔记\图片\微信截图_20221104112912.png" style="zoom:50%;" />

我们要实现这个功能：

- 我们不关心手机内部变压器，内部怎么存储电灯
- 我们不关心这个充电线怎么制作的
- 我们只知道，我们拿着充电线插进充电接口就可以充电
- 这和充电接口就是一个API

## 1.3、Web API

Web API是浏览器提供的一套操作浏览器功能和页面元素和API（BOM和DOM）。

现阶段我们主要针对浏览器讲解常用的API，主要针对浏览器做交互效果。

比如我们想要浏览器弹出一个警示框，直接使用alert('弹出')

MDN详细API：[](https://developer.mozilla.org/zh-CN/docs/Web/API)

因为Web API很多，所以我们将这个阶段称为Web APIs



# 第二章、DOM

## 2.1、DOM简介

### 2.1.1、什么是DOM

文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML 或者XML）的标准编程接口。

W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。

### 2.1.2、DOM树

<img src="E:\笔记\图片\微信截图_20221105001602.png" style="zoom: 67%;" />

- 文档：一个页面就是一个文档，DOM中使用document表示
- 元素：页面中的所有标签都是元素，DOM中使用element表示
- 节点：网页中的所有内容都是节点（标签、属性、文本、注释等）、DOM中使用 node 表示

## 2.2、获取元素

### 2.2.1、如何获取页面元素

DOM在我们实际开发中主要用来操作元素。

我们如何来获取页面中的元素呢?

获取页面中的元素可以使用以下几种方式:

| 方法                                    | 描述                        |
| --------------------------------------- | --------------------------- |
| document.getElementById(*id*)           | 通过元素 id 来获取元素。    |
| document.getElementsByTagName(*name*)   | 通过标签名来获取元素。      |
| document.getElementsByClassName(*name*) | 通过类名来获取元素。        |
| document.querySelector(*CSS选择器*)     | 通过CSS选择器选择一个元素。 |
| document.querySelectorAll(*CSS选择器*)  | 通过CSS选择器选择多个元素。 |



### 2.2.2、根据ID获取

使用 getElementById() 方法可以获取带有 ID 的元素对象。

语法：

`document.getElementById('id');`

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>getElementByld获取元素</title>
</head>
<body>
    <div id="time">2019-9-9</div>
    <script>
        //  1.因为我们文档页面从上往下加载，所以先得有标签，所以我们script写到标签的下面
        //  2.get 获得 element 元素 by 通过 驼峰命名法
        //  3.参数 id是大小写敏感的字符串
        //  4.返回的是一个元素对象
        var timer = document.getElementById('time');
        console.log(timer);
        console.log(typeof timer); //object
        // 5. console.dir 打印我们返回的元素对象，更好的查看里面的属性和方法
        console.dir(timer);
    </script>
</body>
</html>
~~~

需求描述：创建一个按钮，通过id获取按钮节点对象

~~~javascript
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<button id="btn">我是按钮</button>

<!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 -->
<script>
    var btn = document.getElementById("btn");
    console.log(btn);
</script>
</body>
</html>
~~~

<img src="E:\笔记\图片\微信截图_20221105011031.png" style="zoom: 80%;" />

### 2.2.3、根据标签名获取

使用 getElementsByTagName() 方法可以返回带有指定标签名的对象的集合。

语法：

` document.getElementsByTagName('标签名');`

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>getElementByTagName</title>
</head>
<body>
       <ul>
            <li>1在这美丽的夜里,等你等到我心碎。</li>
            <li>2在这美丽的夜里,等你等到我心碎。</li>
            <li>3在这美丽的夜里,等你等到我心碎。</li>
        </ul>
        <script>
            // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的
            var lis = document.getElementsByTagName('li');
            console.log(lis);
            console.log(lis[0]);
            // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式
            for(var i = 0;i < lis.length;i++) {
                console.log(lis[i]);
            }
            // 3.如果页面中只有一个li 返回的还是伪数组的形式
            // 4.如果页面中没有这个元素，返回的是一个空的伪数组
        </script>
</body>
</html>
~~~

需求描述:创建一个按钮，通过标签名获取按钮节点对象数组

~~~javascript
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<button>我是按钮</button>

<!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 -->
<script>
    var btn = document.getElementsByTagName("button");
    console.log(btn);
</script>
</body>
</html>
~~~

<img src="E:\笔记\图片\微信截图_20221105015112.png" style="zoom: 70%;" />

> 注意：
>
> 1.  因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。
> 2.  获取过来元素对象的集合是以==伪数组==的形式存储的
> 3.  得到元素对象是动态的

### 2.2.4、通过类名获取

语法：

`document.getElementsByClassName(‘类名’)；`

需求描述：创建一个按钮，通过类名获取按钮节点对象数组

~~~javascript
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<button class="btn">我是按钮</button>

<!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 -->
<script>
    var btn = document.getElementsByClassName("btn");
    console.log(btn);
</script>
</body>
</html>
~~~

### 2.2.5、  通过CSS选择器选择一个元素

语法：

` document.querySelector('选择器');`

> 注意：根据指定选择器返回==第一个==元素对象。

需要描述：创建一个按钮，通过CSS选择器选择该按钮

~~~javascript
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<button class="btn">我是按钮</button>

<!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 -->
<script>
    var btn = document.querySelector(".btn");
    console.log(btn);
</script>
</body>
</html>
~~~

### 2.2.6、通过CSS选择器选择多个元素

语法：

`document.querySelectorAll('选择器');`

需求描述：创建一个无序列表，通过CSS选择器选择该列表的所有li

~~~javascript
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<ul class="list">
    <li>列表项1</li>
    <li>列表项2</li>
    <li>列表项3</li>
    <li>列表项4</li>
</ul>

<!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 -->
<script>
    var list = document.querySelectorAll(".list li");
    console.log(list);
</script>
</body>
</html>
~~~

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div class="box">盒子1</div>
    <div class="box">盒子2</div>
    <div id="nav"></div>
        <ul>
            <li>首页</li>
            <li>产品</li>
        </ul>
        <script>
            //1. getElementByClassName 根据类名获得某些元素集合
            var boxs = document.getElementsByClassName('box');
            console.log(boxs);
            
            // 2. querySelector 返回指定选择器的第一个元素对象 切记 里面的选择器需要加符号 .box #nav
            var firstBox = document.querySelector('.box');
            console.log(firstBox);
            var nav = document.querySelector('#nav');
            console.log(nav);
            var li = document.querySelector('li');
            console.log(li);

            //3. querySelectorAll() 返回指定选择器的所有元素对象的集合
            var allBox = document.querySelectorAll('.box')
            console.log(allBox);
            var lis = document.querySelectorAll('li')
            console.log(lis);
        </script>
</body>
</html>
~~~

> 注意：querySelector 和 querySelectorAll里面的选择器需要加符号,比如:document.querySelector('==**#**==nav');

### 2.2.7、获取特殊元素（body,html）

- 获取body元素

  语法：

  `doucumnet.body // 返回body元素对象`

- 获取html元素

  语法：

  `document.documentElement // 返回html元素对象`

  ~~~javascript
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>获取特殊元素</title>
  </head>
  <body>
      <script>
          // 1. 获取body元素
          var bodyEle = document.body;
          console.log(bodyEle);
          console.dir(bodyEle);
  
          // 2. 获取html元素
          var htmlEle = document.documentElement;
          console.log(htmlEle);
      </script>
  </body>
  </html>
  ~~~

  

## 2.3、事件基础

### 2.3.1、事件概述

JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。

简单理解： 触发--- 响应机制。

网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。

### 2.3.2、事件三要素

1. 事件源 （事件被触发的对象）
2. 事件类型（如何触发 什么事件  比如鼠标点击（onclick）还是鼠标经过 还是键盘按下）
3. 事件处理程序  （通过一个函数赋值的方式  完成）

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>事件三要素</title>
</head>
<body>
    <button id="btn">唐伯虎</button>
    <script>
        // 点击一个按钮,弹出对话框
        // 1. 时间是有三部分组成的  事件源 事件类型 时间处理程序  我们也称为事件三要素

        //(1) 事件源 事件被触发的对象  谁  按钮
        var btn = document.getElementById('btn');

        //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下
        //(3) 事件处理程序  通过一个函数赋值的方式完成
        btn.onclick = function () {
            alert('点秋香');
        }
    </script>    
</body>
</html>
~~~

### 2.3.3、执行事件的步骤

1. 获取事件源
2. 注册事件（绑定事件）
3. 添加事件处理程序（采取函数赋值形式）

### 2.2.4、常见的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| ondblclick  | 鼠标双击触发     |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |



## 2.4、操作元素

javaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。

| 方法                               | 描述                        |
| ---------------------------------- | --------------------------- |
| 元素节点.innerText                 | 获取HTML元素的inner Text。  |
| 元素节点.innerHTML                 | 获取HTML元素的inner HTML。  |
| 元素节点.属性                      | 获取HTML 元素的属性值。     |
| 元素节点.getAttribute(*attribute*) | 获取 HTML 元素的属性值。    |
| 元素节点.style 样式                | 获取HTML 元素的行内样式值。 |

### 2.4.1、改变元素内容

`element.innerText`

从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉。

`element.innerHTML`

起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行。

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>操作元素</title>
    <style>
        div,
        p {
            width: 300px;
            height: 30px;
            line-height: 30px;
            color: #fff;
            background-color: blueviolet;
        }
    </style>
</head>
<body>
    <button>某个当前系统时间</button>
    <div>某个时间</div>
    <p>123</p>
    <script>
        // 1.获取元素
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        // 2.注册事件
        btn.onclick = function() {
            div.innerHTML = getDate(); //修改元素内容
        }

        function getDate () {
            var date = new Date();
        var year = date.getFullYear();
        var month = date.getMonth() + 1;
        var dates = date.getDate();
        var arr = ['星期日','星期一','星期一','星期二','星期三','星期四','星期五','星期六'];
        var day = date.getDay();
        return '今天是' + year + '年' +month + '月' + dates + '日 ' + arr[day];

        }


        //元素可以不用添加事件 直接显示时间
        var p = document.querySelector('p');
        p.innerHTML = getDate();
    </script>
</body>
</html>
~~~

**innerText和innerHTML区别：**

> ~~~javascript
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <meta http-equiv="X-UA-Compatible" content="IE=edge">
>     <meta name="viewport" content="width=device-width, initial-scale=1.0">
>     <title>innerText和innerHTML区别</title>
> </head>
> <body>
>     <div></div>
>     <p>
>         我是文字
>         <span>123</span>
>     </p>
>     <script>
>         //  innerText 和 innerHTML的区别
>         // 1. innerText 不识别html标签 非标准  去除空格和换行
>         var div = document.querySelector('div');
>         // 2. innerHTML 识别html标签 W3C标准  保留空格和换行
>         div.innerText = '<strong>今天是<strong> 2022';
>         // div.innerHTML = '<strong>今天是<strong> 2022';
> 
>             // 这两个属性是可读写的  可以获取元素里面的内容
>             var p = document.querySelector('p');
>             console.log(p.innerText);
>             console.log(p.innerHTML);
> 
>     </script>
> </body>
> </html>
> ~~~
>
> ![](E:\笔记\图片\微信截图_20221105144156.png)
>
> ![](E:\笔记\图片\微信截图_20221105144207.png)

### 2.4.2、常用元素的属性操作

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>操作元素之修改元素属性</title>
</head>
<body>
    <button id="ldh">刘德华</button>
    <button id="zxy">张学友</button>
    <img src="images/ldh.jpg" alt="">
    <script>
        //修改元素属性src
        // 1.获取元素
        var ldh = document.getElementById('ldh');
        var zxy = document.getElementById('zxy');
        var img = document.querySelector('img');

        // 2.注册事件 处理程序
        zxy.onclick = function() {
            img.src = 'images/zxy.jpg';
            img.title = '张学友';
        }
        ldh.onclick = function() {
            img.src = 'images/ldh.jpg';
            img.title = '刘德华';
        }

    </script>
</body>
</html>
~~~

案例：分时显示不同图片，显示不同问候语

根据不同时间，页面显示不同图片，同时显示不同的问候语

如果（上午/下午/晚上）时间打开页面，显示（上午好/下午好/晚上好）上午好，显示（上午/下午/晚上）的图片

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        img {
            width: 300px;
        }
    </style>
</head>
<body>
    <img src="images/zaoshang.jpg" alt="">
    <div>早上好</div>
    <script>
        // 1. 获取元素
        var img = document.querySelector('img');
        var div = document.querySelector('div');

        // 2. 得到当前的小时数
        var date = new Date();
        var h = date.getHours();
        // 3.判断小时数改变图片和文字信息
        if(h < 12) {
            img.src = 'images/zaoshang.jpg';
            div.innerHTML = '早上好';
        } else if (h < 18){
            img.src = 'images/zhongwu.jpg';
            div.innerHTML = '中午好';
        } else {
            img.src = 'images/wanshang.jpg';
            div.innerHTML = '晚上好';
        }
    </script>
</body>
</html>
~~~

### 2.4.3、表单元素的属性操作

利用DOM可以操作如下表单元素的属性：

type、value、checked、selected、disabled

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>操作元素之修改元素属性</title>
</head>
<body>
     <button>按钮</button>
     <input type="text" value="输入内容">
     <script>
        // 1. 获取元素
        var btn = document.querySelector('button');
        var input = document.querySelector('input');
        // 2. 注册事件 处理程序
        btn.onclick = function() {
            //表单里面的值 文字内容是通过 value 来修改的
            input.value = '被点击了';
            // 如果想要某个表单被禁用 不能再点击 disabled 我们想要这个按钮 button 禁用
            // btn.disabled = true;
            this.disabled = true;
            // this 指向的是事件函数的调用者 btn
        }
     </script>
</body>
</html>
~~~

案例：仿京东显示（隐藏）密码

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>仿京东显示密码</title>
    <style>
        .box {
            position: relative;
            width: 400px;
            border-bottom: 1px solid #ccc;
            margin: 100px auto;
        }
        .box input {
            width: 370px;
            height: 30px;
            border: 0;
            outline: none;
        }
        .box img {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 24px;
        }
    </style>
</head>
<body>
    <div class="box">
    <label for="">
        <img src="../JavaScript/DOM/images/close.png" alt="" id="eye">
    </label>
    <input type="password" name="" id="pwd">
    </div>
    <script>
        // 1.获取元素
        var eye = document.getElementById('eye');
        var pwd = document.getElementById('pwd');
        // 2. 绑定事件 处理程序
        var falg = true;
        eye.onclick = function() {
            if(falg == true) {
                eye.src = '../JavaScript/DOM/images/open.png';
                pwd.type = 'text';
                falg = false;
            }else {
                eye.src = '../JavaScript/DOM/images/close.png';
                pwd.type = 'password';
                falg = true;
            }
        }
        
        
    </script>
</body>
</html>
~~~

### 2.4.4、样式属性操作

我们可以通过JS修改元素的大小，颜色，位置等样式。

| 方法              | 描述         |
| ----------------- | ------------ |
| element.style     | 行内样式操作 |
| element.ClassName | 类名样式操作 |

#### 2.4.4.1、element.style修改样式

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>操作元素之修改元素属性</title>
    <style>
        div {
            width: 200px;
            height: 100px;
            background-color:pink;
        }
    </style>
</head>
<body>
    <div></div>
    <script>
        // 1.获取元素
        var div = document.querySelector('div');
        // 2.注册事件 处理程序
        div.onclick = function() {
            this.style.backgroundColor = 'red';
            this.style.width = '250px'
                
            }
    </script>
</body>
</html>
~~~

> 注意:
>
> - JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor
> - JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高

#### 2.4.4.2、element.className修改样式

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>通过className修改元素样式</title>
    <style>
        div {
            background-color: pink;
            height: 200px;
            width: 200px;
        }
        .change {
            background-color: bisque;
            width: 250;
            width: 250px;
            margin-top: 100px;
        }
    </style>
</head>
<body>
    <div class="first">文本</div>
    <script>
        // 1. 使用element.style 获得修改元素样式 如果样式比较少 或者 功能简单的情况下使用
        var text = document.querySelector('div');
        text.onclick = function() {
            // this.style.backgroundColor = 'red';
            // this.style.width = '300px';
            // this.style.height = '300px';
            // this.style.marginTop = '100px';

            // 2.我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
            // 3. 如果想要保留原先的类名,我们可以这么做 多类名选择器
            this.className = 'first change';
        }
    </script>
</body>
</html>
~~~

> 注意:
>
> 1. 如果样式修改较多，可以采取操作类名方式更改元素样式。
> 2. class因为是个保留字，因此使用className来操作元素类名属性
> 3.  className 会直接更改元素的类名，会覆盖原先的类名。

### 2.4.5、操作元素总结

操作元素是DOM核心内容

~~~mermaid
graph LR;
    操作元素-->操作元素内容-->innerText;
    操作元素内容-->innerHTML;
    操作元素-->操作常见元素属性-->src,href,title,alt等;
    操作元素-->操作表单元素属性-->type,value,disabled等;
    操作元素-->操作元素样式属性-->element.styLe;
    操作元素样式属性-->classNane
~~~

经典案例：表单全选取消全选

~~~javascript
<!DOCTYPE html>
<html>

<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
        
        .wrap {
            width: 300px;
            margin: 100px auto 0;
        }
        
        table {
            border-collapse: collapse;
            border-spacing: 0;
            border: 1px solid #c0c0c0;
            width: 300px;
        }
        
        th,
        td {
            border: 1px solid #d0d0d0;
            color: #404060;
            padding: 10px;
        }
        
        th {
            background-color: #09c;
            font: bold 16px "微软雅黑";
            color: #fff;
        }
        
        td {
            font: 14px "微软雅黑";
        }
        
        tbody tr {
            background-color: #f0f0f0;
        }
        
        tbody tr:hover {
            cursor: pointer;
            background-color: #fafafa;
        }
    </style>

</head>

<body>
    <div class="wrap">
        <table>
            <thead>
                <tr>
                    <th>
                        <input type="checkbox" id="j_cbAll" />
                    </th>
                    <th>商品</th>
                    <th>价钱</th>
                </tr>
            </thead>
            <tbody id="j_tb">
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>iPhone8</td>
                    <td>8000</td>
                </tr>
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>iPad Pro</td>
                    <td>5000</td>
                </tr>
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>iPad Air</td>
                    <td>2000</td>
                </tr>
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>Apple Watch</td>
                    <td>2000</td>
                </tr>

            </tbody>
        </table>
    </div>
    <script>
        // 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可
        // 获取元素
        var j_cbAll = document.getElementById('j_cbAll'); // 全选按钮
        var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); // 下面所有的复选框
        // 注册事件
        j_cbAll.onclick = function() {
                // this.checked 它可以得到当前复选框的选中状态如果是true 就是选中，如果是false 就是未选中
                console.log(this.checked);
                for (var i = 0; i < j_tbs.length; i++) {
                    j_tbs[i].checked = this.checked;
                }
            }
            // 2. 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。
        for (var i = 0; i < j_tbs.length; i++) {
            j_tbs[i].onclick = function() {
                // flag 控制全选按钮是否选中
                var flag = true;
                // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中
                for (var i = 0; i < j_tbs.length; i++) {
                    if (!j_tbs[i].checked) {
                        flag = false;
                        break; // 退出for循环 这样可以提高执行效率 因为只要有一个没有选中，剩下的就无需循环判断了
                    }
                }
                j_cbAll.checked = flag;
            }
        }
    </script>
</body>

</html>
~~~

### 2.4.6、自定义属性的操作

#### 2.4.6.1、获取属性值

- `element.属性 //获取属性值`
- `element.getAttribute('属性');`

> 区别：
>
> - element.属性  获取内置属性值（元素本身自带的属性）
> - element.getAttribute('属性'); 主要获得自定义的属性 （标准）我们程序员自定义的属性

~~~javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="demo" index="1" class="nav"></div>
    <script>
        var div = document.querySelector('div');
        // 1. 获取元素的属性值
        // (1) element.属性
        console.log(div.id);
        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己		 添加的属性我们称为自定义属性 index
        console.log(div.getAttribute('id'));
        console.log(div.getAttribute('index'));
    </script>
</body>
</html>
~~~

#### 2.4.6.2、设置(改变)属性值

- ` element.属性 = ‘值’`
- `element.setAttribute('属性', '值');`

> 区别：
>
> - element.属性 设置内置属性值
> - element.setAttribute(‘属性’);  主要设置自定义的属性 （标准）

~~~javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="demo" index="1" class="nav"></div>
    <script>
        // 2. 设置元素属性值
        // (1) element.属性= '值'
        div.id = 'test';
        div.className = 'navs';
        // (2) element.setAttribute('属性', '值');  主要针对于自定义属性
        div.setAttribute('index', 2);
        div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是class 不是className
    </script>
</body>

</html>
~~~

#### 2.4.6.3、移除属性

- `element.removeAttribute('属性');`

~~~javascript
<script>
    // 3 移除属性 removeAttribute(属性)    
    div.removeAttribute('index');
</script>
~~~

#### 2.4.6.4、H5自定义属性

自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。

自定义属性获取是通过getAttribute(‘属性’) 获取。

但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。

H5给我们新增了自定义属性：

1. 设置H5自定义属性

   ==H5规定自定义属性data-开头做为属性名并且赋值。==

   比如    `<div data-index="1"><div>`

   或者使用JS设置

   `element.setAttribute(‘data-index’, 2)`

2. 获取H5自定义属性

   1. 兼容性获取 `element.getAttribute(‘data-index’);`
   2.  H5新增 element.dataset.index 或者 element.dataset[‘index’] ie 11才开始支持



## 2.5、节点操作

### 2.5.1、为什么需要节点操作

获取元素通常使用两种方式：

1.  **利用 DOM 提供的方法获取元素**
   - document.getElementById() 
   - document.getElementsByTagName()
   -  document.querySelector 等
   -  逻辑性不强、繁琐
2. **利用节点层级关系获取元素**
   - 利用父子兄节点关系获取元素
   -  逻辑性强

这两种方式都可以获取元素节点，后面都会使用，但是节点操作更简单。

### 2.5.2、节点概述

一般地，一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。

- 元素节点 nodeType 为 1 
- 属性节点 nodeType 为 2 
-  文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）

> 我们在实际开发中，节点操作主要操作的是==元素节点==

### 2.5.3、节点层级

利用DOM树可以把节点划分为不同的层级关系，常见的是==父子兄层级关系==。

<img src="E:\笔记\图片\微信截图_20221109132716.png" style="zoom:50%;" />

#### 2.5.3.1、父级节点

语法：

~~~javascript
node.parentNode
~~~

- parentNode 属性可返回某节点的父节点，注意是最近的一个父节点
- 如果指定的节点没有父节点则返回 null
- 案例：

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>节点操作之父节点</title>
</head>
<body>
    <div class="box">
        <span class="erweima">x</span>
    </div>
    <script>
        // 1.父节点 parentNote
        var erweima = document.querySelector('.erweima');
        // var box = document.querySelector('.box');
        // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回 null
        console.log(erweima.parentNode);
    </script>
</body>
</html>
~~~

#### 2.5.3.2、子节点

~~~javascript
parentNode.childNodes（）
~~~

parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。

> 注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。 如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNodes

~~~javascript
var ul = document. querySelector(‘ul’);
for(var i = 0; i < ul.childNodes.length;i++) {
if (ul.childNodes[i].nodeType == 1) {
 // ul.childNodes[i] 是元素节点
 console.log(ul.childNodes[i]);
}
}
~~~

~~~javascript
2. parentNode.children（） //主要使用这个
~~~

> parentNode.children 是一个只读属性，返回==所有的==子元素节点。它只返回子元素节点，其余节点不返回 （==这个重点掌握的==）。

虽然children 是一个非标准，但是得到了各个浏览器的支持，因此可以放心使用。

---

~~~javascript
parentNode.firstChild
~~~

firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。

~~~javascript
parentNode.lastChild 
~~~

lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。



实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？

> 解决方案：
>
> 1. 如果想要第一个子元素节点，可以使用 parentNode.chilren[0] 
> 2. 如果想要最后一个子元素节点，可以使用 parentNode.chilren[parentNode.chilren.length - 1] 

---

**实际开发中更加常用以下这两个**：

~~~javascript
arentNode.firstElementChild
~~~

firstElementChild 返回第一个子元素节点，找不到则返回null。

~~~javascript
parentNode.lastElementChild 
~~~

lastElementChild 返回最后一个子元素节点，找不到则返回null。 

#### 2.5.3.3、兄弟节点

~~~javas
node.nextSibling
~~~

nextSibling 返回当前元素的下一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。

~~~javascript
node.previousSibling
~~~

previousSibling 返回当前元素上一个兄弟元素节点，找不到则返回null。同样，也是包含所有的节点。

> 以上方法返回的节点包含全部节点（元素、属性、文本）

---

~~~javascript
node.nextElementSibling 
~~~

nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。

~~~javascript
node.previousElementSibling
~~~

previousElementSibling 返回当前元素上一个兄弟节点，找不到则返回null。

案例：

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>我是div</div>
    <span>我是span</span>
    <script>
        var div = document.querySelector('div');
        // 1. nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等
        console.log(div.nextSibling);
        console.log(div.previousSibling);
        // 2. nextElementSibling 得到下一个兄弟元素
        console.log(div.nextElementSibling);
        console.log(div.previousElementSibling);
    </script>
</body>
</html>
~~~

#### 2.5.3.4、创建节点

~~~javascript
document.createElement('tagName')
~~~

document.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在， 是根据我们的需求动态生成的，所以我们也称为==动态创建元素节点==。

案例：

~~~javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <ul>
        <li>123</li>
    </ul>
    <script>
        // 1. 创建节点元素节点
        var li  = document.createElement('li');
        // 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素  类似于数组中的push
        var ul = document.querySelector('ul');
        ul.appendChild(li);
        // 3. 添加节点 node.insertBefore(child, 指定元素);
        var lili =  document.createElement('li');
        ul.insertBefore(lili,ul.children[0]);
        // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素
    </script>
</body>
</html>
~~~

#### 2.5.3.5、添加节点

~~~javascript
node.appendChild(child) 
~~~

node.appendChild() 方法将一个节点添加到指定父节点的子节点列表==末尾==。类似于 CSS 里面的 after 伪元素。

~~~javascript
node.insertBefore(child, 指定元素) 
~~~

node.insertBefore() 方法将一个节点添加到父节点的指定子节点==前面==。类似于 CSS 里面的 before  伪元素

#### 2.5.3.6、删除节点

~~~javascript
 node.removeChild(child) 
~~~

node.removeChild() 方法从 DOM 中删除一个==子节点==，返回删除的节点。

案例：

~~~javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <button>删除</button>
    <ul>
        <li>熊大</li>
        <li>熊二</li>
        <li>光头强</li>
    </ul>
    <script>
        // 1.获取元素
        var ul = document.querySelector('ul');
        var btn = document.querySelector('button');
        // 2. 删除元素  node.removeChild(child)
        // ul.removeChild(ul.children[0]);
        // 3. 点击按钮依次删除里面的孩子
        btn.onclick = function() {
            if (ul.children.length == 0) {
                this.disabled = true;
            } else {
                ul.removeChild(ul.children[0]);
            }
        }
    </script>
</body>
</html>
~~~

综合案例：添加删除留言案例

~~~javascript

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        
        body {
            padding: 100px;
        }
        
        textarea {
            width: 200px;
            height: 100px;
            border: 1px solid pink;
            outline: none;
            resize: none;
        }
        
        ul {
            margin-top: 50px;
        }
        
        li {
            width: 300px;
            padding: 5px;
            background-color: rgb(245, 209, 243);
            color: red;
            font-size: 14px;
            margin: 15px 0;
        }
        
        li a {
            float: right;
        }
    </style>
</head>

<body>
    <textarea name="" id=""></textarea>
    <button>发布</button>
    <ul>

    </ul>
    <script>
        // 1. 获取元素
        var btn = document.querySelector('button');
        var text = document.querySelector('textarea');
        var ul = document.querySelector('ul');
        // 2. 注册事件
        btn.onclick = function() {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var li = document.createElement('li');
                // 先有li 才能赋值
                li.innerHTML = text.value + "<a href='javascript:;'>删除</a>";
                // (2) 添加元素
                // ul.appendChild(li);
                ul.insertBefore(li, ul.children[0]);
                // (3) 删除元素 删除的是当前链接的li  它的父亲
                var as = document.querySelectorAll('a');
                for (var i = 0; i < as.length; i++) {
                    as[i].onclick = function() {
                        // node.removeChild(child); 删除的是 li 当前a所在的li  
                        //this.parentNode;
                        ul.removeChild(this.parentNode);
                        //删除当前的父节点
                    }
                }
            }
        }
    </script>
</body>

</html>
~~~

#### 2.5.3.7、复制节点（克隆节点）

~~~javascript
 node.cloneNode() 
~~~

node.cloneNode() 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点

> 注意：
>
> 1. 如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。
> 2. 如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点。

案例：

~~~javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <ul>
        <li>1111</li>
        <li>2</li>
        <li>3</li>
    </ul>
    <script>
        var ul = document.querySelector('ul');
        // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
        // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
        var lili = ul.children[0].cloneNode(true);
        ul.appendChild(lili);
    </script>
</body>
</html>
~~~

### 2.5.4、三种动态创建元素的区别

-  document.write()
-  element.innerHTML
- document.createElement()

区别：

1.  document.write 是直接将内容写入页面的内容流，==但是文档流执行完毕，则它会导致页面全部重绘==
2. innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘
3. innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
4.  createElement() 创建多个元素效率稍低一点点，但是结构更清晰

> 不同浏览器下，innerHTML 效率要比 creatElement 高



### 2.5.5、DOM重点核心

关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。

1. 创建
   - document.write
   - innerHTMl
   - createElement
2. 增
   - appendChild
   - insertBefore
3. 删
   - removeChild
4. 改
   - 主要修改dom的元素属性，dom元素的内容、属性、表单的值等
   - 修改元素属性：src、href、title等
   - 修改普通元素内容：innerHTML、innerText
   - 修改表单元素：value、type、disabled等
   - 修改元素样式：style、className
5. 查
   - 主要获取查询dom的元素
   - DOM提供的API方法： getElementById、getElementsByTagName 古老用法 不太推荐
   - H5提供的新方法：querySelector、querySelectorAll  **提倡**
   - 利用节点操作获取元素： 父(parentNode)、子(children)、兄(previousElementSibling、 nextElementSibling)  **提倡**
6. 属性操作
   - 主要针对自定义属性。
   - setAttribute：设置dom的属性值
   - getAttribute：得到dom的属性值
   - removeAttribute移除属性
7. 事件操作
   - 给元素注册事件，采取  事件源.事件类型 = 事件处理程序 
   - （未完待续）



## 2.7、事件高级

### 2.7.1、注册事件（绑定事件）

#### 2.7.1.1、注册事件概述

给元素添加事件，称为==注册事件==或者==绑定事件==

注册事件有两种方式：==传统方式和方法监听方式==

传统注册方式：

- 利用 on 开头的事件 onclick
- <button onclick=“alert('hi~')”></button>
- btn.onclick = function() {}
- 特点： 注册事件的唯一性
- 同一个元素同一个事件只能设置一个处理函数，最 后注册的处理函数将会覆盖前面注册的处理函数

方法监听注册方式：

- w3c 标准 推荐方式
- ==addEventListener() 它是一个方法==
- IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替
- 特点：同一个元素同一个事件可以注册多个监听器
- 按注册顺序依次执行

#### 2.7.1.2、addEventListener 事件监听方式

语法：

`eventTarget.addEventListener(type, listener[, useCapture])`

eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对 象触发指定的事件时，就会执行事件处理函数。

该方法接收三个参数：

- ==type==：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on
- ==listener==：事件处理函数，事件发生时，会调用该监听函数
- ==useCapture==：可选参数，是一个布尔值。如果是 true，表示在事件捕 获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理程序。

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=`, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button>出台弄注册事件</button>
    <button>方法监听注册事件</button>
    <script>
        var btns = document.querySelectorAll('button');
        // 1. 传统方式注册事件
        btns[0].onclick = function() {
            alert('hi~');
        }
        // 2. 事件监听注册事件  addEventListener 
        // (1)里面的时间类型是字符串 必定加引号 而且不带on
        // (2)同一个元素 同一个事件可以添加多个监听器(事件处理程序)

        btns[1].addEventListener('click',function() {
            alert(22);
        })
        btns[1].addEventListener('click',function() {
            alert(33);
        })
       
    </script>
</body>
</html>
~~~

### 2.7.2、删除事件（解绑事件）

#### 2.7.2.1、删除事件的方式

1. 传统注册方式

   `eventTarget.onclick = null;`

2. 方法监听注册方式

   `eventTarget.removeEventListener(type, listener[, useCapture]);`

~~~javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            width: 100px;
            height: 100px;
            background-color: #ccc;
        }
    </style>
</head>
<body>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
        var divs = document.querySelectorAll('div');
        divs[0].onclick = function() {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        // 2. removeEventListener 删除事件
        divs[1].addEventListener('click',fn) // 里面的fn 不需要调用小括号
        function fn () {
            alert(22);
            divs[1].removeEventListener('click',fn);
        }
    </script>
</body>
</html>
~~~

### 2.7.3、DOM事件流

==事件流==描述的是从页面中接收事件的顺序

==事件==发生时会在元素节点之间按照特定的顺序传播，这个==传播过程==即==DOM事件流==

比如我们给一个div 注册了点击事件：

DOM 事件流分为3个阶段：

1. 捕获阶段
2. 当前目标阶段
3. 冒泡阶段

<img src="E:\笔记\图片\微信截图_20221116101908.png"  />

- 事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。
- 事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。

> 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具 体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过 程相当于事件冒泡。

<img src="E:\笔记\图片\微信截图_20221116102120.png" style="zoom: 80%;" />

注意：

1. . JS 代码中只能执行捕获或者冒泡其中的一个阶段。
2. onclick 和 attachEvent 只能得到冒泡阶段。
3. addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕 获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理 程序。
4. ==实际开发中我们很少使用事件捕获，我们更关注事件冒泡==。
5. ==有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave==
6. 事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件。

~~~javascript
<script>
        // dom 事件流 三个阶段
        // 1. JS 代码中只能执行捕获或者冒泡其中一个阶段
        // 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段
        // 3. 捕获阶段 如果addEventListener  第三个参数是 true 那么处于捕获阶段 document --> html -->  body --> father --> son

        // var son = document.querySelector('.son');
        // son.addEventListener('click',function() {
        //     alert('son');
        // },true)
        // var father = document.querySelector('.father');
        // father.addEventListener('click',function() {
        //     alert('father');
        // },true)

        // 4.冒泡阶段 如果addEventListener  第三个参数是 false 那么处于冒泡阶段 son --> father -->  body --> html --> document
        var son = document.querySelector('.son');
        son.addEventListener('click',function() {
            alert('son');
        },false)
        var father = document.querySelector('.father');
        father.addEventListener('click',function() {
            alert('father');
        },false)
		// 这里不写第三个参数，默认就是false
        document.addEventListener('click',function() {
            alert('document');
        })
    </script>
~~~

### 2.7.4、事件对象

#### 2.7.4.1、什么是事件对象

官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。

简单理解：事件发生后，==跟事件相关的一系列信息数据的集合==都放到这个对象里面，这个对象就是==事件对象 event==，它有很多属性和方法。

比如：

1. 谁绑定了这个事件。
2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。

#### 2.7.4.2、事件对象的使用语法

~~~javascript
eventTarget.onclick = function(event) {
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 
 } 
 eventTarget.addEventListener('click', function(event) {
 // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt 
 }
~~~

这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。

当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。

~~~javascript
<body>
    <div>123</div>
    <script>
        // 事件对象
        var div = document.querySelector('div');
        // div.onclick = function(e) {
        //     console.log(e);
        // }

        div.addEventListener('click',function(e) {
            console.log(e);
        })

        // 1. event 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看
        // 2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数
        // 3. 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键
        // 4. 这个事件对象我们可以自己命名 比如 event 、 evt、 e
        // 5. 事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法  e = e || window.event;
    </script>
</body>
~~~

### 2.7.5、事件对象的常见属性和方法

| 事件对象属性方法    | 说明                                              |
| ------------------- | ------------------------------------------------- |
| e.target            | 返回==触发==事件的对象                            |
| e.type              | 返回事件的类型  比如 click mouseover 不带 on      |
| e.preventDefault()  | 该方法 阻止默认事件 （默认行为） 比如不让链接跳转 |
| e.stopPropagation() | 阻止冒泡                                          |

> e.target 和 this 的区别：
>
> - this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素
> - e.target 是事件触发的元素。

~~~javascript
<body>
    <div>123</div>
    <a href="http://www.baidu.com">百度</a>
    <form action="http://www.baidu.com">
        <input type="submit" value="提交" name="sub">
    </form>
    <script>
        // 常见时间对象的属性和方法
        // 1. 返回时间类型
        var div = document.querySelector('div');
        div.addEventListener('click',fn);
        div.addEventListener('mouseover',fn);
        div.addEventListener('mouseout',fn);
    
        function fn(e) {
            console.log(e.type);
        }

        // 2. 阻止默认行为(事件) 让链接不跳转 或者让提交按钮不提交
        var a = document.querySelector('a');
        a.addEventListener('click',function(e) {
            e.preventDefault();  //dom标准写法
        })

        // 3. 传统的注册方式
        a.onclick = function(e) {
            // 普通浏览器 e.preventDefault();  方法
            // e.preventDefault();
            // 低版本浏览器 ie678  returnValue  属性
            // e.returnValue;
            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式
            return false;
            alert(11);
        }
    </script>
~~~

#### 2.7.5.1、阻止事件冒泡

事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。

利用事件对象里面的 stopPropagation()方法

` e.stopPropagation()`

~~~javascript
 var son = document.querySelector('.son');
        son.addEventListener('click', function(e) {
            alert('son');
            e.stopPropagation(); // stop 停止  Propagation 传播
            e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 IE678专用（可忽略）
        }, false);
~~~

### 2.7.6、事件委托（代理、委派）

事件委托也称为事件代理， 在 jQuery 里面称为事件委派。

> 事件委托原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。

事件委托的作用：我们只操作了一次DOM，提高了程序的性能。

案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。

~~~javascript
<body>
    <ul>
        <li>知否知否，点我应有弹框在手！</li>
        <li>知否知否，点我应有弹框在手！</li>
    </ul>
    <script>
        // 事件委托的核心原理：给父节点添加侦听器，利用时间冒泡影响每一个子节点
        var ul = document.querySelector('ul');
        ul.addEventListener('click',function(e) {
            // alert('你好~');
            e.target.style.backgroundColor = 'pink';
        })
    </script>
</body>
~~~

### 2.7.7、常用的鼠标事件

#### 2.7.7.1、常用的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| ondblclick  | 鼠标双击触发     |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

- 禁止鼠标右键菜单

  contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

  ~~~javascript
  document.addEventListener('contextmenu', function(e) {
  e.preventDefault();
  })
  ~~~

- 禁止鼠标选中（selectstart 开始选中）

  ~~~javascript
  document.addEventListener('selectstart', function(e) {
   e.preventDefault();
   })
  ~~~

#### 2.7.7.2、鼠标事件对象

==event==对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 ==MouseEvent== 和键盘事件对象 ==KeyboardEvent==。

| 鼠标事件对象 | 说明                                  |
| ------------ | ------------------------------------- |
| e.clientX    | 返回鼠标相对于浏览器窗口可视区的X坐标 |
| e.clientY    | 返回鼠标相对于浏览器窗口可视区的Y坐标 |
| e.pageX      | 返回鼠标相对于文档页面的X坐标         |
| e.pageY      | 返回鼠标相对于文档页面的Y坐标         |
| e.screenX    | 返回鼠标相对于电脑屏幕的X坐标         |
| e.screenY    | 返回鼠标相对于电脑屏幕的X坐标         |

~~~javascript
<script>
        // 鼠标事件对象MouseEvent
        document.addEventListener('click',function(e) {
            // 1. client 鼠标子啊可视区的x和y坐标
            console.log(e.clientX);
            console.log(e.clientY);
            console.log('------------------------');

            // 2.page 鼠标在页面文档的x和y坐标
            console.log(e.pageX);
            console.log(e.pageY);
            console.log('------------------------');

            // 3. screen 鼠标在电脑屏幕的x和y坐标
            console.log(e.screenX);
            console.log(e.screenY);
        })
    </script>
~~~

案例：跟随鼠标的天使

~~~javascript
<script>
        var pic = document.querySelector('img');
        document.addEventListener('mousemove', function(e) {
            // 1. mousemove只要我们鼠标移动1px 就会触发这个事件
            // console.log(1);
          // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片
            var x = e.pageX;
            var y = e.pageY;
            console.log('x坐标是' + x, 'y坐标是' + y);
            //3 . 千万不要忘记给left 和top 添加px 单位
            pic.style.left = x - 50 + 'px';
            pic.style.top = y - 40 + 'px';
        });
</script>
~~~

### 2.7.8、常用的键盘事件

#### 2.7.8.1、常用键盘事件

事件除了使用鼠标触发，还可以使用键盘触发

| 键盘事件   | 触发条件                                                     |
| ---------- | ------------------------------------------------------------ |
| onkeyup    | 某个键盘按键被松开时触发                                     |
| onkeydown  | 某个键盘按键被按下时触发                                     |
| onkeypress | 某个键盘按键被按下时触发    ==但是它不识别功能按键 比如 Ctrl shift 箭头等== |

> 注意：
>
> 1. **如果使用addEventListener 不需要加 on**
> 2. onkeypress 和前面2个的区别是，它不识别功能键，比如 左右箭头，shift 等。
> 3. 三个事件的执行顺序是：keydown -- keypress -- keyup

~~~javascript
<script>
        //常用的键盘事件
        //1.keyup 按键弹起的时候触发
        // document.onkeyup = function() {
        //     console.log('我弹起来了~');
        // }
        document.addEventListener('keyup',function() {
            console.log('我弹起了');
        })

        // 2. keydown 按键按下的时候触发 能识别功能键 比如 Ctrl  shift 左右箭头
        document.addEventListener('keydown',function() {
            console.log('我按下了down');
        })
        // 3. keypress 按键按下的时候触发 不能识别功能键 比如 Ctrl shift 左右箭头
        document.addEventListener('keypress',function() {
            console.log('我按下了press');
        })
        // 4. 三个事件的执行顺序 keydowm -- keypress -- keyup
    </script>
~~~

#### 2.7.8.2、键盘事件对象

| 键盘事件对象属性 | 说明              |
| ---------------- | ----------------- |
| key              | 返回按键按下的值  |
| keyCode          | 返回该键的ASCII值 |

注意：

- onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。
- 在我们实际开发中，我们更多的使用keydown和keyup， 它能识别所有的键（包括功能键）
- Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值

案例： 模拟京东快递单号查询

~~~javascript
<script>
        // 快递单号输入内容时， 上面的大号字体盒子（con）显示(这里面的字号更大）
        // 表单检测用户输入： 给表单添加键盘事件
        // 同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容
        // 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子
        var con = document.querySelector('.con');
        var jd_input = document.querySelector('.jd');
        jd_input.addEventListener('keyup', function(){
                // console.log('输入内容啦');
                if(this.value == '') {
                    con.style.display = 'none';
                }else {
                    con.style.display = 'block';
                    con.innerText = this.value;
                }
            })
            // 当我们失去焦点，就隐藏这个con盒子
        jd_input.addEventListener('blur', function() {
                con.style.display = 'none';
            })
            // 当我们获得焦点，就显示这个con盒子
        jd_input.addEventListener('focus', function() {
            if (this.value !== '') {
                con.style.display = 'block';
            }
        })
    </script>
~~~



# 第三章、BOM

## 3.1、BOM概述

### 3.1.1、什么是BOM

BOM（Browser Object Model）即==浏览器对象模型==，它提供了独立于内容而与==浏览器窗口进行交互的对象==，其核心 对象是 window。

BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。

BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏 览器标准的一部分。



DOM

- 文档对象模型
- DOM 就是把「==文档==」当做一个「==对象==」来看待
- DOM 的顶级对象是 ==document==
- DOM 主要学习的是操作页面元素
- DOM 是 W3C 标准规范

BOM

- 浏览器对象模型
- 把「==浏览器==」当做一个「==对象==」来看待
- BOM 的顶级对象是 ==window==
- BOM 学习的是浏览器窗口交互的一些对象
- BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差

### 3.1.2、BOM的构成

BOM 比 DOM 更大，它包含 DOM

<img src="E:\笔记\图片\微信截图_20221120113928.png" style="zoom:75%;" />

- Window：代表的是整个浏览器的窗口，同时window也是网页中的全局对象
- Navigator：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
- Location：代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
- History：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
- Screen：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息

这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用。



## 3.2、window对象的常见事件

### 3.2.1、弹出框

JavaScript 有三种类型的弹出框：警告框、确认框和提示框。

#### 3.2.1.1、警告框

如果要确保信息传递给用户，通常会使用警告框。当警告框弹出时，用户将需要单击“确定”来继续

语法：

`window.alert("请输入密码！");`

> 注意：window.alert() 方法可以不带 window 前缀来写。

~~~javascript
alert("我是一个警告框！");
~~~

#### 3.2.1.2、确认框

如果您希望用户验证或接受某个东西，则通常使用“确认”框。

当确认框弹出时，用户将不得不单击“确定”或“取消”来继续进行。

如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。

语法：

`window.confirm("sometext");`

> 注意：window.confirm() 方法可以不带 window 前缀来编写。

实例：

~~~javascript
var r = confirm("请按按钮");
if (r == true) {
    x = "您按了确认！";
} else {
    x = "您按了取消！";
}
~~~

#### 3.2.1.3、提示框

如果您希望用户在进入页面前输入值，通常会使用提示框。

当提示框弹出时，用户将不得不输入值后单击“确定”或点击“取消”来继续进行。

如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。

语法：

`window.prompt("sometext","defaultText");`

> window.prompt() 方法可以不带 window 前缀来编写。

~~~javascript
var person = prompt("请输入您的姓名", "程朗");
if (person != null) {
    console.log(person);
}
~~~

### 3.2.2、窗口加载事件

~~~javascript
window.onload = function(){}
或者
window.addEventListener("load",function(){});
~~~

window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS  文件等), 就调用的处理函数。

注意：

1. 有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。
2. window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。
3. 如果使用 addEventListener 则没有限制

---

~~~javascript
document.addEventListener('DOMContentLoaded',function(){})
~~~

DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。

Ie9以上才支持

如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用 户的体验，此时用 DOMContentLoaded 事件比较合适

### 3.2.3、调整窗口大小事件

~~~javascript
window.onresize = function(){}
或者
window.addEventListener("resize",function(){});
~~~

window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。

注意：

1. 只要窗口大小发生像素变化，就会触发这个事件。
2.  我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度。



## 3.3、定时器与延时器

### 3.3.1、setTimeout() 延时器

setTimeout() 方法用于设置一个延时器，该延时器在延时器到期后执行调用函数。

语法：

` window.setTimeout(调用函数, [延迟的毫秒数]);`

> 注意：window.setTimeout() 方法可以不带 window 前缀来编写。

- 第一个参数是要执行的函数。
- 第二个参数指示执行之前的毫秒数。
-  这个调用函数可以==直接写函数==，或者==写函数名==或者采取字符串‘函数名()'三种形式。第三种不推荐
- 延迟的毫秒数省略默认是 0，如果写，必须是毫秒
- 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符

~~~javascript
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<button id="btn">按钮</button>

<!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 -->
<script>
    var btn = document.getElementById("btn");

    btn.onclick = function () {
        // 创建延时器
        var timer = setTimeout(function () {
            console.log("Hello");
        }, 3000);
        
        // 清除延时器
        // clearTimeout(timer);        
    };
</script>
</body>
</html>
~~~

---

setTimeout() 这个调用函数我们也称为==回调函数 callback==

普通函数是按照代码顺序直接调用。

而这个函数，==需要等待==时间，时间到了才去调用这个函数，因此称为回调函数。

简单理解： 回调，就是回头调用的意思。上一件事干完，再==回==头再==调==用这个==函数==。 

以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调函数。

### 3.3.2、停止setTimeout()延时器

语法：

` window.clearTimeout(timeoutID)`

clearTimeout()方法取消了先前通过调用 setTimeout() 建立的延时器。

注意：

1. window可以省略。
2. 里面的参数就是延时器的标识符。

### 3.3.3、setInterval()延时器

语法：

`window.setInterval(function, milliseconds);`

> 注意：window.setInterval() 方法可以不带 window 前缀来写

- 第一个参数是要执行的函数。
- 第二个参数每个执行之间的时间间隔的长度。
- 这个调用函数可以直接写函数，或者写函数名或者采取字符串 '函数名()' 三种形式。
- 间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。
- 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。
- 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。

### 3.3.4、停止setInterval()定时器

语法：

`window.clearInterval(intervalID);`

clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。

注意：

1. window 可以省略。
2. 里面的参数就是定时器的标识符 。

---

### 3.3.5、定时器与延时器的区别

> setTimeout  延时时间到了，就去调用这个回调函数，只调用一次 就结束了这个定时器
>
> setInterval 每隔这个延时时间，就去调用这个回调函数，会调用很多次，重复调用这个函数

### 3.3.6、this指向问题

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this 的最终指向的是那个调用它的对象

现阶段，我们先了解一下几个this指向

1. 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）

   ~~~javascript
   / 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）
           console.log(this);
   
           function fn() {
               console.log(this);
   
           }
           window.fn();
           window.setTimeout(function() {
               console.log(this);
   
           }, 1000);
   ~~~

   

2. 方法调用中谁调用this指向谁

   ~~~JavaScript
   // 2. 方法调用中谁调用this指向谁
           var o = {
               sayHi: function() {
                   console.log(this); // this指向的是 o 这个对象
   
               }
           }
           o.sayHi();
           var btn = document.querySelector('button');
           // btn.onclick = function() {
           //     console.log(this); // this指向的是btn这个按钮对象
   
           // }
           btn.addEventListener('click', function() {
                   console.log(this); // this指向的是btn这个按钮对象
   
               })
   ~~~

3. 构造函数中this指向构造函数的实例

   ~~~javascript
   // 3. 构造函数中this指向构造函数的实例
           function Fun() {
               console.log(this); // this 指向的是fun 实例对象
   
           }
           var fun = new Fun();
   ~~~

   

## 3.4、JS执行机制

### 3.4.1、JS是单线程

JavaScript 语言的一大特点就是==单线程==，也就是说，==同一个时间只能做一件事==。这是因为 Javascript 这门脚 本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对 某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

### 3.4.2、同步和异步

为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创 建多个线程。于是，JS 中出现了==同步==和==异步==。

**同步：**前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。

**异步：**前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。

> 他们的本质区别： 这条流水线上各个流程的执行顺序不同。

同步任务：同步任务都在主线程上执行，形成一个==执行栈==。

<img src="E:\笔记\图片\微信截图_20221122121501.png" style="zoom:50%;" />

异步任务：JS 的异步是通过回调函数实现的。

一般而言，异步任务有以下三种类型:

1. 普通事件，如 click、resize 等
2. 资源加载，如 load、error 等
3. 定时器，包括 setInterval、setTimeout 等

异步任务相关==回调函数==添加到==任务队列==中（任务队列也称为消息队列）。

<img src="E:\笔记\图片\微信截图_20221122121534.png" style="zoom:50%;" />

### 3.4.3、JS执行机制

1.  先执行==执行栈==中的同步任务。
2. 异步任务（回调函数）放入任务队列中。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取==任务队列==中的异步任务，于是被读取的异步任 务结束等待状态，进入执行栈，开始执行。

<img src="E:\笔记\图片\微信截图_20221122121859.png" style="zoom:50%;" />

<img src="E:\笔记\图片\微信截图_20221122122134.png" style="zoom:70%;" />

由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。



## 3.5、location对象

### 3.5.1、什么是location对象

window 对象给我们提供了一个 ==location 属性==用于==获取或设置窗体的 URL==，并且可以用于==解析 URL== 。 因为 这个属性返回的是一个对象，所以我们将这个属性也称为 ==location 对象==。

### 3.5.2、URL

==统一资源定位符 (Uniform Resource Locator, URL)== 是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

URL的一般语法格式为：

~~~html
protocol://host[:port]/path/[?query]#fragment
http://www.itcast.cn/index.html?name=andy&age=18#link
~~~

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| protocal | 通信协议 常用的http，ftp，maito等                            |
| host     | 主机（域名）www.baidu.com                                    |
| port     | 端口号 可选，省略时使用方案的默认端口 如http的默认端口是80   |
| path     | 路径 由 零或多个 '/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |
| query    | 参数 以键值对的形式，通过&符号分隔开来                       |
| fragment | 片段 #后面内容 常见于链接 锚点                               |

### 3.5.3、location对象的属性

| location对象属性  | 返回值                             |
| ----------------- | ---------------------------------- |
| location.href     | 获取或者设置 整个URL               |
| location.host     | 返回主机 （域名） www.baidu.com    |
| location.port     | 返回端口号 如果未写返回 空字符串   |
| location.pathname | 返回路径                           |
| location.search   | 返回参数                           |
| location.hash     | 返回片段 #后面内容 常见于链接 锚点 |

> 重点记住：href 和search

### 3.5.4、location对象的方法

| location对象方法   | 返回值                                                       |
| ------------------ | ------------------------------------------------------------ |
| location.assign()  | 跟href一样，可以跳转页面（也称为重定向页面）                 |
| location.replace() | 替换当前页面，因为不记录历史，所以不能后退页面               |
| location.reload()  | 重新加载页面，相当于刷新按钮或者f5,如果参数为true强制刷新ctrl+f5 |



## 3.6、Navigator对象

Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器，由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用userAgent来判断浏览器的信息，userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent.如下代码：

~~~javascript
var ua = navigator.userAgent;
console.log(ua);
~~~

## 3.7、history对象

window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中） 访问过的 URL。

| history对象方法 | 作用                                                         |
| --------------- | ------------------------------------------------------------ |
| back()          | 可以后退功能                                                 |
| forward()       | 前进功能                                                     |
| go(参数)        | 前进后退功能，参数如果是1 前进一个页面，如果是-1 后退一个页面 |

